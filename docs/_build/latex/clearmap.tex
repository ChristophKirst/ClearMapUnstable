% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\usepackage[utf8]{inputenc}
\DeclareUnicodeCharacter{00A0}{\nobreakspace}
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{babel}
\usepackage{times}
\usepackage[Bjarne]{fncychap}
\usepackage{longtable}
\usepackage{sphinx}
\usepackage{multirow}


\addto\captionsenglish{\renewcommand{\figurename}{Fig. }}
\addto\captionsenglish{\renewcommand{\tablename}{Table }}
\floatname{literal-block}{Listing }



\title{ClearMap Documentation}
\date{December 18, 2015}
\release{0.9.2}
\author{Christoph Kirst}
\newcommand{\sphinxlogo}{}
\renewcommand{\releasename}{Release}
\makeindex

\makeatletter
\def\PYG@reset{\let\PYG@it=\relax \let\PYG@bf=\relax%
    \let\PYG@ul=\relax \let\PYG@tc=\relax%
    \let\PYG@bc=\relax \let\PYG@ff=\relax}
\def\PYG@tok#1{\csname PYG@tok@#1\endcsname}
\def\PYG@toks#1+{\ifx\relax#1\empty\else%
    \PYG@tok{#1}\expandafter\PYG@toks\fi}
\def\PYG@do#1{\PYG@bc{\PYG@tc{\PYG@ul{%
    \PYG@it{\PYG@bf{\PYG@ff{#1}}}}}}}
\def\PYG#1#2{\PYG@reset\PYG@toks#1+\relax+\PYG@do{#2}}

\expandafter\def\csname PYG@tok@gd\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.63,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@gu\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.50,0.00,0.50}{##1}}}
\expandafter\def\csname PYG@tok@gt\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.27,0.87}{##1}}}
\expandafter\def\csname PYG@tok@gs\endcsname{\let\PYG@bf=\textbf}
\expandafter\def\csname PYG@tok@gr\endcsname{\def\PYG@tc##1{\textcolor[rgb]{1.00,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@cm\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@vg\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@m\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@mh\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@cs\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}\def\PYG@bc##1{\setlength{\fboxsep}{0pt}\colorbox[rgb]{1.00,0.94,0.94}{\strut ##1}}}
\expandafter\def\csname PYG@tok@ge\endcsname{\let\PYG@it=\textit}
\expandafter\def\csname PYG@tok@vc\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@il\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@go\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.20,0.20,0.20}{##1}}}
\expandafter\def\csname PYG@tok@cp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@gi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.63,0.00}{##1}}}
\expandafter\def\csname PYG@tok@gh\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
\expandafter\def\csname PYG@tok@ni\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.84,0.33,0.22}{##1}}}
\expandafter\def\csname PYG@tok@nl\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.13,0.44}{##1}}}
\expandafter\def\csname PYG@tok@nn\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\expandafter\def\csname PYG@tok@no\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.38,0.68,0.84}{##1}}}
\expandafter\def\csname PYG@tok@na\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@nb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@nc\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\expandafter\def\csname PYG@tok@nd\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.33,0.33,0.33}{##1}}}
\expandafter\def\csname PYG@tok@ne\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@nf\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.49}{##1}}}
\expandafter\def\csname PYG@tok@si\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.44,0.63,0.82}{##1}}}
\expandafter\def\csname PYG@tok@s2\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@vi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@nt\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.45}{##1}}}
\expandafter\def\csname PYG@tok@nv\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@s1\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@gp\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\expandafter\def\csname PYG@tok@sh\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@ow\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@sx\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\expandafter\def\csname PYG@tok@bp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@c1\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@kc\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@c\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@mf\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@err\endcsname{\def\PYG@bc##1{\setlength{\fboxsep}{0pt}\fcolorbox[rgb]{1.00,0.00,0.00}{1,1,1}{\strut ##1}}}
\expandafter\def\csname PYG@tok@mb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@ss\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.32,0.47,0.09}{##1}}}
\expandafter\def\csname PYG@tok@sr\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.14,0.33,0.53}{##1}}}
\expandafter\def\csname PYG@tok@mo\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@kd\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@mi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@kn\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@o\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PYG@tok@kr\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@s\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@kp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@w\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.73,0.73}{##1}}}
\expandafter\def\csname PYG@tok@kt\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.56,0.13,0.00}{##1}}}
\expandafter\def\csname PYG@tok@sc\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@sb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@k\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@se\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@sd\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}

\def\PYGZbs{\char`\\}
\def\PYGZus{\char`\_}
\def\PYGZob{\char`\{}
\def\PYGZcb{\char`\}}
\def\PYGZca{\char`\^}
\def\PYGZam{\char`\&}
\def\PYGZlt{\char`\<}
\def\PYGZgt{\char`\>}
\def\PYGZsh{\char`\#}
\def\PYGZpc{\char`\%}
\def\PYGZdl{\char`\$}
\def\PYGZhy{\char`\-}
\def\PYGZsq{\char`\'}
\def\PYGZdq{\char`\"}
\def\PYGZti{\char`\~}
% for compatibility with earlier versions
\def\PYGZat{@}
\def\PYGZlb{[}
\def\PYGZrb{]}
\makeatother

\renewcommand\PYGZsq{\textquotesingle}

\begin{document}

\maketitle
\tableofcontents
\phantomsection\label{index::doc}


\emph{ClearMap} is a toolbox for the analysis and registration of volumetric data
from cleared tissues.

\emph{ClearMap} is targeted towards large lightsheet volumetric imaging data
of iDISCO+ cleared mouse brains samples, their registration to the Alan brain atlas,
volumetric image processing and statistical analysis.


\chapter{Contents}
\label{index:clearmap}\label{index:contents}

\section{Introduction}
\label{introduction:introduction}\label{introduction::doc}
\emph{ClearMap} is a toolbox to analyze and register microscopy images of cleared
tissue. It is targeted towards cleared brain tissue using the {\hyperref[introduction:idisco-clearing-method]{\emph{iDISCO+ Clearing Method}}}
but can be used with any volumetric imaging data.

The package consists of four main modules:
\begin{itemize}
\item {} 
{\hyperref[introduction:io]{\emph{IO}}} for reading and writing images and data

\item {} 
{\hyperref[introduction:alignment]{\emph{Alignment}}} for resampling, reorientation and registration of images onto references

\item {} 
{\hyperref[introduction:image-processing]{\emph{Image Processing}}} for correcting and quantifying the image data

\item {} 
{\hyperref[introduction:analysis]{\emph{Analysis}}} for the statistical analysis of the data

\end{itemize}


\subsection{IO}
\label{introduction:io}
ClearMap supports a wide range of image formats with focus on volumetric data:

\begin{tabulary}{\linewidth}{|L|L|}
\hline
\textsf{\relax 
Format
} & \textsf{\relax 
Descrition
}\\
\hline
TIF
 & 
tif images and stacks
\\
\hline
RAW / MHD
 & 
raw image files with optional mhd header file
\\
\hline
NRRD
 & 
nearly raw raster data files
\\
\hline
IMS
 & 
imaris image files
\\
\hline
pattern
 & 
folder, file list or file pattern of a stack of 2d images
\\
\hline\end{tabulary}


Images are represented internally as numpy arrays. CleaMap assumes images
in arrays are aranged as {[}x,y{]}, {[}x,y,z{]} or {[}x,y,z,c{]} where x,y,z correspond to
the x,y,z coordinates as when viewed in an image viewer such as \phantomsection\label{introduction:id1}{\hyperref[introduction:imagej]{\emph{{[}ImageJ{]}}}} and
c to a possible color channel.

ClearMap also supports several data formats storing data points, such as
cell center coordinates or intensities

\begin{tabulary}{\linewidth}{|L|L|}
\hline
\textsf{\relax 
Format
} & \textsf{\relax 
Descrition
}\\
\hline
CSV
 & 
comma separated values in text file
\\
\hline
NPY
 & 
numpy binary file
\\
\hline
VTK
 & 
vtk point data file
\\
\hline\end{tabulary}



\subsection{Alignment}
\label{introduction:alignment}
The Alignment module provides tools to resample, reorient and register
volumetric images in a fast parallel way.

Image registration is done by interfacing to the \phantomsection\label{introduction:id2}{\hyperref[introduction:elastix]{\emph{{[}Elastix{]}}}} software package.

This package allows to align cleared mouse brains onto the Allan brain atlas \phantomsection\label{introduction:id3}{\hyperref[introduction:aba]{\emph{{[}ABA{]}}}}.


\subsection{Image Processing}
\label{introduction:image-processing}
ClearMap provides a number of image processing tools with focus on
processing large 3d volumetric images in parallel.

Main processing modules include:

\begin{tabulary}{\linewidth}{|L|L|}
\hline
\textsf{\relax 
Module
} & \textsf{\relax 
Descrition
}\\
\hline
{\hyperref[api/ClearMap.ImageProcessing:module-ClearMap.ImageProcessing.BackgroundRemoval]{\emph{\code{BackgroundRemoval}}}}
 & 
Background estimation and removal via morphological opening
\\
\hline
{\hyperref[api/ClearMap.ImageProcessing:module-ClearMap.ImageProcessing.IlluminationCorrection]{\emph{\code{IlluminationCorrection}}}}
 & 
Correction of vignetting and other illumination errors
\\
\hline
{\hyperref[api/ClearMap.ImageProcessing.Filter:module-ClearMap.ImageProcessing.Filter]{\emph{\code{Filter}}}}
 & 
Filtering of the imagee via large set of filter kernels
\\
\hline
{\hyperref[api/ClearMap.ImageProcessing:module-ClearMap.ImageProcessing.GreyReconstruction]{\emph{\code{GreyReconstruction}}}}
 & 
Reconstruction of images
\\
\hline
{\hyperref[api/ClearMap.ImageProcessing:module-ClearMap.ImageProcessing.SpotDetection]{\emph{\code{SpotDetection}}}}
 & 
Detection of local peaks
\\
\hline
{\hyperref[api/ClearMap.ImageProcessing:module-ClearMap.ImageProcessing.CellDetection]{\emph{\code{CellDetection}}}}
 & 
Detection of cell centers
\\
\hline
{\hyperref[api/ClearMap.ImageProcessing:module-ClearMap.ImageProcessing.CellSizeDetection]{\emph{\code{CellSizeDetection}}}}
 & 
Detection of cell shapes via watershed
\\
\hline
{\hyperref[api/ClearMap.ImageProcessing:module-ClearMap.ImageProcessing.IlastikClassification]{\emph{\code{IlastikClassification}}}}
 & 
Classification of voxels via interface to \phantomsection\label{introduction:id4}{\hyperref[introduction:ilastik]{\emph{{[}Ilastik{]}}}}
\\
\hline\end{tabulary}


The modular structure of this sub-packages allows for fast and felxible integration of
additional modules.


\subsection{Analysis}
\label{introduction:analysis}
This part of ClearMap provides a toolbox for the statistical analysis and
visualization of detected cells or structures and region specific analysis
of annoated data.

For cleared mouse brains aligned to the \phantomsection\label{introduction:id5}{\hyperref[introduction:aba]{\emph{{[}ABA{]}}}} a wide range of statistical
analysis tools with respect to the anotated brain regions in the atlas is
supported.

Key moduls are

\begin{tabulary}{\linewidth}{|L|L|}
\hline
\textsf{\relax 
Module
} & \textsf{\relax 
Descrition
}\\
\hline
{\hyperref[api/ClearMap.Analysis:module-ClearMap.Analysis.Voxelization]{\emph{\code{Voxelization}}}}
 & 
Voxelization of cells for visualization and analysis
\\
\hline
{\hyperref[api/ClearMap.Analysis:module-ClearMap.Analysis.Statistics]{\emph{\code{Statistics}}}}
 & 
Statistical tools for the analysis of detected cells
\\
\hline
{\hyperref[api/ClearMap.Analysis:module-ClearMap.Analysis.Label]{\emph{\code{Label}}}}
 & 
Tools to analysise data with espect to annotated refereneces
\\
\hline\end{tabulary}



\subsection{Examples}
\label{introduction:examples}
Examples can be found \code{here} and in the api documentation.


\subsection{iDISCO+ Clearing Method}
\label{introduction:idisco-clearing-method}
iDISCO stands for immunolabeling-enabled three-dimensional imaging
of solvent-cleared organs. The iDISCO+ clearance method is
decribed in \phantomsection\label{introduction:id6}{\hyperref[introduction:renier2014]{\emph{{[}Renier2014{]}}}} and \phantomsection\label{introduction:id7}{\hyperref[introduction:renier2015]{\emph{{[}Renier2015{]}}}}.

iDISCO is modeled on classical histology techniques, facilitating translation
of section staining assays to intact tissues, as evidenced by compatibility
with 28 antibodies to both endogenous antigens and transgenic reporters
like GFP. iDISCO enables facile volume imaging of immunolabeled structures
in complex tissues
\begin{description}
\item[{See these videos}] \leavevmode\begin{itemize}
\item {} 
\href{https://www.youtube.com/watch?v=-ctRUMQjizgvbLtLYkW6hI}{Dopaminergic system in the embryonic mouse}

\item {} 
\href{https://www.youtube.com/watch?v=vbLtLYkW6hI}{Cortical and hippocampal neurons in the adult mouse brain}

\end{itemize}

\end{description}

More info can be found on the \phantomsection\label{introduction:id8}{\hyperref[introduction:idisco]{\emph{{[}iDISCO{]}}}} webpage.


\subsection{References}
\label{introduction:references}

\section{ClearMap package}
\label{api/ClearMap:clearmap-package}\label{api/ClearMap::doc}\phantomsection\label{api/ClearMap:module-ClearMap}\index{ClearMap (module)}
\emph{ClearMap} Registration, Image Analysis and Statistics Library.

\emph{ClearMap} is a python toolbox for the analysis and registration of volumetric
data from cleared tissues.

\emph{ClearMap} is targeted towards large lightsheet volumetric imaging data
of iDISCO+ cleared mouse brains samples, their registration to the Alan brain atlas,
volumetric image processing and statistical analysis.

Author
\begin{quote}

Christoph Kirst,
The Rockefeller University, New York City, 2015
\end{quote}

License
\begin{quote}

GNU GENERAL PUBLIC LICENSE Version 3
\end{quote}


\subsection{Subpackages}
\label{api/ClearMap:subpackages}

\subsubsection{ClearMap.IO package}
\label{api/ClearMap.IO:clearmap-io-package}\label{api/ClearMap.IO::doc}\label{api/ClearMap.IO:module-ClearMap.IO}\index{ClearMap.IO (module)}
This sub-package provides routines to read and write data
\begin{description}
\item[{Two types of data files are discriminated:}] \leavevmode\begin{itemize}
\item {} 
{\hyperref[api/ClearMap.IO:image-data]{\emph{Image data}}}

\item {} 
{\hyperref[api/ClearMap.IO:point-data]{\emph{Point data}}}

\end{itemize}

\end{description}

Image data are files with data from the microscopy or results representing
visualization of the analysis in e.g. volumetric form.

Point data are lists of e.g. cell coordinates or measured
intensitites.


\paragraph{Image data}
\label{api/ClearMap.IO:image-data}
Images are represented internally as numpy arrays. CleaMap assumes images
in arrays are aranged as {[}x,y{]}, {[}x,y,z{]} or {[}x,y,z,c{]} where x,y,z correspond to
the x,y,z coordinates as when viewed in an image viewer such as ImageJ.
The c coordinate is a possible color channel.

\begin{notice}{note}{Note:}
Many image libraries read images as {[}y,x,z{]} or {[}y,x{]} arrays!
\end{notice}

The ClearMap toolbox supports a range of (volumetric) image formats:

\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textsf{\relax 
Format
} & \textsf{\relax 
Descrition
} & \textsf{\relax 
Module
}\\
\hline
TIF
 & 
tif images and stacks
 & 
{\hyperref[api/ClearMap.IO:module-ClearMap.IO.TIF]{\emph{\code{TIF}}}}
\\
\hline
RAW / MHD
 & 
raw image files with optional mhd header file
 & 
{\hyperref[api/ClearMap.IO:module-ClearMap.IO.RAW]{\emph{\code{RAW}}}}
\\
\hline
NRRD
 & 
nearly raw raster data files
 & 
{\hyperref[api/ClearMap.IO:module-ClearMap.IO.NRRD]{\emph{\code{NRRD}}}}
\\
\hline
IMS
 & 
imaris image file
 & 
{\hyperref[api/ClearMap.IO:module-ClearMap.IO.Imaris]{\emph{\code{Imaris}}}}
\\
\hline
reg exp
 & 
folder, file list or file pattern of a stack of 2d images
 & 
{\hyperref[api/ClearMap.IO:module-ClearMap.IO.FileList]{\emph{\code{FileList}}}}
\\
\hline\end{tabulary}


The image format is inferred automatically from the file name extension.

For example to read image data use {\hyperref[api/ClearMap.IO:ClearMap.IO.IO.readData]{\emph{\code{readData()}}}}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{os}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{ClearMap.IO} \PYG{k+kn}{as} \PYG{n+nn}{io}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{ClearMap.Settings} \PYG{k+kn}{as} \PYG{n+nn}{settings}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{filename} \PYG{o}{=} \PYG{n}{os}\PYG{o}{.}\PYG{n}{path}\PYG{o}{.}\PYG{n}{join}\PYG{p}{(}\PYG{n}{settings}\PYG{o}{.}\PYG{n}{ClearMapPath}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Test/Data/Tif/test.tif}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{data} \PYG{o}{=} \PYG{n}{io}\PYG{o}{.}\PYG{n}{readData}\PYG{p}{(}\PYG{n}{filename}\PYG{p}{)}\PYG{p}{;}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print} \PYG{n}{data}\PYG{o}{.}\PYG{n}{shape}
\PYG{g+go}{(20, 50, 10)}
\end{Verbatim}

To write image data use {\hyperref[api/ClearMap.IO:ClearMap.IO.IO.writeData]{\emph{\code{writeData()}}}}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{os}\PYG{o}{,} \PYG{n+nn}{numpy}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{ClearMap.IO} \PYG{k+kn}{as} \PYG{n+nn}{io}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{ClearMap.Settings} \PYG{k+kn}{as} \PYG{n+nn}{settings}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{filename} \PYG{o}{=} \PYG{n}{os}\PYG{o}{.}\PYG{n}{path}\PYG{o}{.}\PYG{n}{join}\PYG{p}{(}\PYG{n}{settings}\PYG{o}{.}\PYG{n}{ClearMapPath}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Test/Data/Tif/test.tif}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{data} \PYG{o}{=} \PYG{n}{numpy}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{rand}\PYG{p}{(}\PYG{l+m+mi}{20}\PYG{p}{,}\PYG{l+m+mi}{50}\PYG{p}{,}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{;}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{data}\PYG{p}{[}\PYG{l+m+mi}{5}\PYG{p}{:}\PYG{l+m+mi}{15}\PYG{p}{,} \PYG{l+m+mi}{20}\PYG{p}{:}\PYG{l+m+mi}{45}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{:}\PYG{l+m+mi}{9}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{data} \PYG{o}{=} \PYG{l+m+mi}{20} \PYG{o}{*} \PYG{n}{data}\PYG{p}{;}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{data} \PYG{o}{=} \PYG{n}{data}\PYG{o}{.}\PYG{n}{astype}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{int32}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{res} \PYG{o}{=} \PYG{n}{io}\PYG{o}{.}\PYG{n}{writeData}\PYG{p}{(}\PYG{n}{filename}\PYG{p}{,} \PYG{n}{data}\PYG{p}{)}\PYG{p}{;}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print} \PYG{n}{io}\PYG{o}{.}\PYG{n}{dataSize}\PYG{p}{(}\PYG{n}{res}\PYG{p}{)}\PYG{p}{;}
\PYG{g+go}{(20, 50, 10)}
\end{Verbatim}

Generally, the IO module is desinged to work with image sources which can be
either files or already loaded numpy arrays. This is important to enable flexible
parallel processing, without rewriting the data analysis routines.

For example:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{numpy}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{ClearMap.IO} \PYG{k+kn}{as} \PYG{n+nn}{io}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{data} \PYG{o}{=} \PYG{n}{numpy}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{rand}\PYG{p}{(}\PYG{l+m+mi}{20}\PYG{p}{,}\PYG{l+m+mi}{50}\PYG{p}{,}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{;}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{res} \PYG{o}{=} \PYG{n}{io}\PYG{o}{.}\PYG{n}{writeData}\PYG{p}{(}\PYG{n+nb+bp}{None}\PYG{p}{,} \PYG{n}{data}\PYG{p}{)}\PYG{p}{;}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print} \PYG{n}{res}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{;}
\PYG{g+go}{(20, 50, 10)}
\end{Verbatim}

Range parameter can be passed in order to only load sub sets of image data,
usefull when the imags are very large. For example to load a sub-image

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{os}\PYG{o}{,} \PYG{n+nn}{numpy}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{ClearMap.IO} \PYG{k+kn}{as} \PYG{n+nn}{io}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{ClearMap.Settings} \PYG{k+kn}{as} \PYG{n+nn}{settings}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{filename} \PYG{o}{=} \PYG{n}{os}\PYG{o}{.}\PYG{n}{path}\PYG{o}{.}\PYG{n}{join}\PYG{p}{(}\PYG{n}{settings}\PYG{o}{.}\PYG{n}{ClearMapPath}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Test/Data/Tif/test.tif}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{res} \PYG{o}{=} \PYG{n}{io}\PYG{o}{.}\PYG{n}{readData}\PYG{p}{(}\PYG{n}{filename}\PYG{p}{,} \PYG{n}{data}\PYG{p}{,} \PYG{n}{x} \PYG{o}{=} \PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{,} \PYG{n}{y} \PYG{o}{=} \PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{6}\PYG{p}{)}\PYG{p}{,} \PYG{n}{z} \PYG{o}{=} \PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print} \PYG{n}{res}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{;}
\PYG{g+go}{(3, 2, 3)}
\end{Verbatim}


\paragraph{Point data}
\label{api/ClearMap.IO:point-data}
ClearMap also supports several data formats for storing arrays of points, such
as cell center coordinates or intensities.

Points are assumed to be an array of coordinates where the first array index
is the point number and the second the spatial dimension, i.e. {[}i,d{]}
The spatial dimension can be extended with additional dimensions
for intensity ,easires or other properties.

Points can also be given as tuples (coordinate arrray, property array).

ClearMap supports the following files formats fro point like data:

\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textsf{\relax 
Format
} & \textsf{\relax 
Descrition
} & \textsf{\relax 
Module
}\\
\hline
CSV
 & 
comma separated values in text file
 & 
{\hyperref[api/ClearMap.IO:module-ClearMap.IO.CSV]{\emph{\code{CSV}}}}
\\
\hline
NPY
 & 
numpy binary file
 & 
{\hyperref[api/ClearMap.IO:module-ClearMap.IO.NPY]{\emph{\code{NPY}}}}
\\
\hline
VTK
 & 
vtk point data file
 & 
{\hyperref[api/ClearMap.IO:module-ClearMap.IO.VTK]{\emph{\code{VTK}}}}
\\
\hline\end{tabulary}


The point file format is inferred automatically from the file name extension.

For example to read point data use {\hyperref[api/ClearMap.IO:ClearMap.IO.IO.readPoints]{\emph{\code{readPoints()}}}}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{os}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{ClearMap.IO} \PYG{k+kn}{as} \PYG{n+nn}{io}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{ClearMap.Settings} \PYG{k+kn}{as} \PYG{n+nn}{settings}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{filename} \PYG{o}{=} \PYG{n}{os}\PYG{o}{.}\PYG{n}{path}\PYG{o}{.}\PYG{n}{join}\PYG{p}{(}\PYG{n}{settings}\PYG{o}{.}\PYG{n}{ClearMapPath}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Test/ImageProcessing/points.txt}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{points} \PYG{o}{=} \PYG{n}{io}\PYG{o}{.}\PYG{n}{readPoints}\PYG{p}{(}\PYG{n}{filename}\PYG{p}{)}\PYG{p}{;}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print} \PYG{n}{points}\PYG{o}{.}\PYG{n}{shape}
\PYG{g+go}{(5, 3)}
\end{Verbatim}

and to write it use {\hyperref[api/ClearMap.IO:ClearMap.IO.IO.writePoints]{\emph{\code{writePoints()}}}}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{os}\PYG{o}{,} \PYG{n+nn}{numpy}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{ClearMap.IO} \PYG{k+kn}{as} \PYG{n+nn}{io}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{ClearMap.Settings} \PYG{k+kn}{as} \PYG{n+nn}{settings}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{filename} \PYG{o}{=} \PYG{n}{os}\PYG{o}{.}\PYG{n}{path}\PYG{o}{.}\PYG{n}{join}\PYG{p}{(}\PYG{n}{settings}\PYG{o}{.}\PYG{n}{ClearMapPath}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Test/ImageProcessing/points.txt}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{points} \PYG{o}{=} \PYG{n}{numpy}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{rand}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{;}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{io}\PYG{o}{.}\PYG{n}{writePoints}\PYG{p}{(}\PYG{n}{filename}\PYG{p}{,} \PYG{n}{points}\PYG{p}{)}\PYG{p}{;}
\end{Verbatim}


\paragraph{Summary}
\label{api/ClearMap.IO:summary}\begin{itemize}
\item {} 
All routines accesing data or data properties accept file name strings or numpy arrays or None

\item {} 
Numerical arrays represent data and point coordinates as {[}x,y,z{]} or {[}x,y{]}

\end{itemize}


\paragraph{ClearMap.IO.IO module}
\label{api/ClearMap.IO:clearmap-io-io-module}\label{api/ClearMap.IO:module-ClearMap.IO.IO}\index{ClearMap.IO.IO (module)}
IO interface to read microscope and point data

Main module to distribute read and writing of individual data formats
to the specialized sub-modules

See {\hyperref[api/ClearMap.IO:module-ClearMap.IO]{\emph{\code{ClearMap.IO}}}} for details.

Author
\begin{quote}

Christoph Kirst, The Rockefeller University, New York City, 2015
\end{quote}
\index{pointFileExtensions (in module ClearMap.IO.IO)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.IO:ClearMap.IO.IO.pointFileExtensions}\pysigline{\bfcode{pointFileExtensions}\strong{ = {[}'csv', `txt', `npy', `vtk', `ims'{]}}}
list of extensions supported as a point data file

\end{fulllineitems}

\index{pointFileTypes (in module ClearMap.IO.IO)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.IO:ClearMap.IO.IO.pointFileTypes}\pysigline{\bfcode{pointFileTypes}\strong{ = {[}'CSV', `NPY', `VTK', `Imaris'{]}}}
list of point data file types

\end{fulllineitems}

\index{pointFileExtensionToType (in module ClearMap.IO.IO)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.IO:ClearMap.IO.IO.pointFileExtensionToType}\pysigline{\bfcode{pointFileExtensionToType}\strong{ = \{`txt': `CSV', `vtk': `VTK', `csv': `CSV', `npy': `NPY', `ims': `Imaris'\}}}
map from point file extensions to point file types

\end{fulllineitems}

\index{dataFileExtensions (in module ClearMap.IO.IO)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.IO:ClearMap.IO.IO.dataFileExtensions}\pysigline{\bfcode{dataFileExtensions}\strong{ = {[}'tif', `tiff', `mhd', `raw', `ims', `nrrd'{]}}}
list of extensions supported as a image data file

\end{fulllineitems}

\index{dataFileTypes (in module ClearMap.IO.IO)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.IO:ClearMap.IO.IO.dataFileTypes}\pysigline{\bfcode{dataFileTypes}\strong{ = {[}'FileList', `TIF', `RAW', `NRRD', `Imaris'{]}}}
list of image data file types

\end{fulllineitems}

\index{dataFileExtensionToType (in module ClearMap.IO.IO)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.IO:ClearMap.IO.IO.dataFileExtensionToType}\pysigline{\bfcode{dataFileExtensionToType}\strong{ = \{`tiff': `TIF', `mhd': `RAW', `nrrd': `NRRD', `raw': `RAW', `ims': `Imaris', `tif': `TIF'\}}}
map from image file extensions to image file types

\end{fulllineitems}

\index{fileExtension() (in module ClearMap.IO.IO)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.IO:ClearMap.IO.IO.fileExtension}\pysiglinewithargsret{\bfcode{fileExtension}}{\emph{filename}}{}
Returns file extension if exists
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{filename} (\emph{str}) --
file name

\item[{Returns}] \leavevmode
\emph{str} --
file extension or None

\end{description}\end{quote}

\end{fulllineitems}

\index{isFile() (in module ClearMap.IO.IO)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.IO:ClearMap.IO.IO.isFile}\pysiglinewithargsret{\bfcode{isFile}}{\emph{source}}{}
Checks if filename is a real file, returns false if it is directory or regular expression
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{source} (\emph{str}) --
source file name

\item[{Returns}] \leavevmode
\emph{bool} --
true if source is a real file

\end{description}\end{quote}

\end{fulllineitems}

\index{isFileExpression() (in module ClearMap.IO.IO)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.IO:ClearMap.IO.IO.isFileExpression}\pysiglinewithargsret{\bfcode{isFileExpression}}{\emph{source}}{}
Checks if filename is a regular expression denoting a file list
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{source} (\emph{str}) --
source file name

\item[{Returns}] \leavevmode
\emph{bool} --
true if source is regular expression with a digit label

\end{description}\end{quote}

\end{fulllineitems}

\index{isPointFile() (in module ClearMap.IO.IO)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.IO:ClearMap.IO.IO.isPointFile}\pysiglinewithargsret{\bfcode{isPointFile}}{\emph{source}}{}
Checks if a file is a valid point data file
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{source} (\emph{str}) --
source file name

\item[{Returns}] \leavevmode
\emph{bool} --
true if source is a point data file

\end{description}\end{quote}

\end{fulllineitems}

\index{isDataFile() (in module ClearMap.IO.IO)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.IO:ClearMap.IO.IO.isDataFile}\pysiglinewithargsret{\bfcode{isDataFile}}{\emph{source}}{}
Checks if a file is a valid image data file
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{source} (\emph{str}) --
source file name

\item[{Returns}] \leavevmode
\emph{bool} --
true if source is an image data file

\end{description}\end{quote}

\end{fulllineitems}

\index{createDirectory() (in module ClearMap.IO.IO)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.IO:ClearMap.IO.IO.createDirectory}\pysiglinewithargsret{\bfcode{createDirectory}}{\emph{filename}}{}
Creates the directory of the file if it does not exists
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{filename} (\emph{str}) --
file name

\item[{Returns}] \leavevmode
\emph{str} --
directory name

\end{description}\end{quote}

\end{fulllineitems}

\index{pointFileNameToType() (in module ClearMap.IO.IO)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.IO:ClearMap.IO.IO.pointFileNameToType}\pysiglinewithargsret{\bfcode{pointFileNameToType}}{\emph{filename}}{}
Returns type of a point file
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{filename} (\emph{str}) --
file name

\item[{Returns}] \leavevmode
\emph{str} --
point data type in {\hyperref[api/ClearMap.IO:ClearMap.IO.IO.pointFileTypes]{\emph{\code{pointFileTypes}}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{dataFileNameToType() (in module ClearMap.IO.IO)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.IO:ClearMap.IO.IO.dataFileNameToType}\pysiglinewithargsret{\bfcode{dataFileNameToType}}{\emph{filename}}{}
Returns type of a image data file
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{filename} (\emph{str}) --
file name

\item[{Returns}] \leavevmode
\emph{str} --
image data type in {\hyperref[api/ClearMap.IO:ClearMap.IO.IO.dataFileTypes]{\emph{\code{dataFileTypes}}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{dataFileNameToModule() (in module ClearMap.IO.IO)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.IO:ClearMap.IO.IO.dataFileNameToModule}\pysiglinewithargsret{\bfcode{dataFileNameToModule}}{\emph{filename}}{}
Return the module that handles io for a data file
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{filename} (\emph{str}) --
file name

\item[{Returns}] \leavevmode
\emph{object} --
sub-module that handles a specific data type

\end{description}\end{quote}

\end{fulllineitems}

\index{pointFileNameToModule() (in module ClearMap.IO.IO)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.IO:ClearMap.IO.IO.pointFileNameToModule}\pysiglinewithargsret{\bfcode{pointFileNameToModule}}{\emph{filename}}{}
Return the module that handles io for a point file
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{filename} (\emph{str}) --
file name

\item[{Returns}] \leavevmode
\emph{object} --
sub-module that handles a specific point file type

\end{description}\end{quote}

\end{fulllineitems}

\index{dataSize() (in module ClearMap.IO.IO)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.IO:ClearMap.IO.IO.dataSize}\pysiglinewithargsret{\bfcode{dataSize}}{\emph{source}, \emph{x=\textless{}built-in function all\textgreater{}}, \emph{y=\textless{}built-in function all\textgreater{}}, \emph{z=\textless{}built-in function all\textgreater{}}, \emph{**args}}{}
Returns array size of the image data needed when read from file and reduced to specified ranges
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{source} (\emph{array or str}) --
source data

\item {} 
\textbf{x,y,z} (\emph{tuple or all}) --
range specifications, \code{all} is full range

\end{itemize}

\item[{Returns}] \leavevmode
\emph{tuple} --
size of the image data after reading and range reduction

\end{description}\end{quote}

\end{fulllineitems}

\index{dataZSize() (in module ClearMap.IO.IO)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.IO:ClearMap.IO.IO.dataZSize}\pysiglinewithargsret{\bfcode{dataZSize}}{\emph{source}, \emph{z=\textless{}built-in function all\textgreater{}}, \emph{**args}}{}
Returns size of the array in the third dimension, None if 2D data
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{source} (\emph{array or str}) --
source data

\item {} 
\textbf{z} (\emph{tuple or all}) --
z-range specification, \code{all} is full range

\end{itemize}

\item[{Returns}] \leavevmode
\emph{int} --
size of the image data in z after reading and range reduction

\end{description}\end{quote}

\end{fulllineitems}

\index{toDataRange() (in module ClearMap.IO.IO)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.IO:ClearMap.IO.IO.toDataRange}\pysiglinewithargsret{\bfcode{toDataRange}}{\emph{size}, \emph{r=\textless{}built-in function all\textgreater{}}}{}
Converts range r to numeric range (min,max) given the full array size
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{size} (\emph{tuple}) --
source data size

\item {} 
\textbf{r} (\emph{tuple or all}) --
range specification, \code{all} is full range

\end{itemize}

\item[{Returns}] \leavevmode
\emph{tuple} --
absolute range as pair of integers

\end{description}\end{quote}


\strong{See also:}


{\hyperref[api/ClearMap.IO:ClearMap.IO.IO.toDataSize]{\emph{\code{toDataSize()}}}}, {\hyperref[api/ClearMap.IO:ClearMap.IO.IO.dataSizeFromDataRange]{\emph{\code{dataSizeFromDataRange()}}}}



\end{fulllineitems}

\index{toDataSize() (in module ClearMap.IO.IO)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.IO:ClearMap.IO.IO.toDataSize}\pysiglinewithargsret{\bfcode{toDataSize}}{\emph{size}, \emph{r=\textless{}built-in function all\textgreater{}}}{}
Converts full size to actual size given range r
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{size} (\emph{tuple}) --
data size

\item {} 
\textbf{r} (\emph{tuple or all}) --
range specification, \code{all} is full range

\end{itemize}

\item[{Returns}] \leavevmode
\emph{int} --
data size

\end{description}\end{quote}


\strong{See also:}


{\hyperref[api/ClearMap.IO:ClearMap.IO.IO.toDataRange]{\emph{\code{toDataRange()}}}}, {\hyperref[api/ClearMap.IO:ClearMap.IO.IO.dataSizeFromDataRange]{\emph{\code{dataSizeFromDataRange()}}}}



\end{fulllineitems}

\index{dataSizeFromDataRange() (in module ClearMap.IO.IO)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.IO:ClearMap.IO.IO.dataSizeFromDataRange}\pysiglinewithargsret{\bfcode{dataSizeFromDataRange}}{\emph{dataSize}, \emph{x=\textless{}built-in function all\textgreater{}}, \emph{y=\textless{}built-in function all\textgreater{}}, \emph{z=\textless{}built-in function all\textgreater{}}, \emph{**args}}{}
Converts full data size to actual size given ranges for x,y,z
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{dataSize} (\emph{tuple}) --
data size

\item {} 
\textbf{x,z,y} (\emph{tuple or all}) --
range specifications, \code{all} is full range

\end{itemize}

\item[{Returns}] \leavevmode
\emph{tuple} --
data size as tuple of integers

\end{description}\end{quote}


\strong{See also:}


{\hyperref[api/ClearMap.IO:ClearMap.IO.IO.toDataRange]{\emph{\code{toDataRange()}}}}, {\hyperref[api/ClearMap.IO:ClearMap.IO.IO.toDataSize]{\emph{\code{toDataSize()}}}}



\end{fulllineitems}

\index{dataToRange() (in module ClearMap.IO.IO)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.IO:ClearMap.IO.IO.dataToRange}\pysiglinewithargsret{\bfcode{dataToRange}}{\emph{data}, \emph{x=\textless{}built-in function all\textgreater{}}, \emph{y=\textless{}built-in function all\textgreater{}}, \emph{z=\textless{}built-in function all\textgreater{}}, \emph{**args}}{}
Reduces data to specified ranges
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{data} (\emph{array}) --
full data array

\item {} 
\textbf{x,z,y} (\emph{tuple or all}) --
range specifications, \code{all} is full range

\end{itemize}

\item[{Returns}] \leavevmode
\emph{array} --
reduced data

\end{description}\end{quote}


\strong{See also:}


{\hyperref[api/ClearMap.IO:ClearMap.IO.IO.dataSizeFromDataRange]{\emph{\code{dataSizeFromDataRange()}}}}



\end{fulllineitems}

\index{readData() (in module ClearMap.IO.IO)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.IO:ClearMap.IO.IO.readData}\pysiglinewithargsret{\bfcode{readData}}{\emph{source}, \emph{**args}}{}
Read data from one of the supported formats
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{source} (\emph{str, array or None}) --
full data array, if numpy array simply reduce its range

\item {} 
\textbf{x,z,y} (\emph{tuple or all}) --
range specifications, \code{all} is full range

\item {} 
\textbf{**args} --
further arguments specific to image data format reader

\end{itemize}

\item[{Returns}] \leavevmode
\emph{array} --
data as numpy array

\end{description}\end{quote}


\strong{See also:}


{\hyperref[api/ClearMap.IO:ClearMap.IO.IO.writeData]{\emph{\code{writeData()}}}}



\end{fulllineitems}

\index{writeData() (in module ClearMap.IO.IO)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.IO:ClearMap.IO.IO.writeData}\pysiglinewithargsret{\bfcode{writeData}}{\emph{sink}, \emph{data}, \emph{**args}}{}
Write data to one of the supported formats
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{sink} (\emph{str, array or None}) --
the destination for the data, if None the data is returned directly

\item {} 
\textbf{data} (\emph{array or None}) --
data to be written

\item {} 
\textbf{**args} --
further arguments specific to image data format writer

\end{itemize}

\item[{Returns}] \leavevmode
\emph{array, str or None} --
data or file name of the written data

\end{description}\end{quote}


\strong{See also:}


{\hyperref[api/ClearMap.IO:ClearMap.IO.IO.readData]{\emph{\code{readData()}}}}



\end{fulllineitems}

\index{copyFile() (in module ClearMap.IO.IO)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.IO:ClearMap.IO.IO.copyFile}\pysiglinewithargsret{\bfcode{copyFile}}{\emph{source}, \emph{sink}}{}
Copy a file from source to sink
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{source} (\emph{str}) --
file name of source

\item {} 
\textbf{sink} (\emph{str}) --
file name of sink

\end{itemize}

\item[{Returns}] \leavevmode
\emph{str} --
name of the copied file

\end{description}\end{quote}


\strong{See also:}


{\hyperref[api/ClearMap.IO:ClearMap.IO.IO.copyData]{\emph{\code{copyData()}}}}, {\hyperref[api/ClearMap.IO:ClearMap.IO.IO.convertData]{\emph{\code{convertData()}}}}



\end{fulllineitems}

\index{copyData() (in module ClearMap.IO.IO)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.IO:ClearMap.IO.IO.copyData}\pysiglinewithargsret{\bfcode{copyData}}{\emph{source}, \emph{sink}}{}
Copy a data file from source to sink, which can consist of multiple files
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{source} (\emph{str}) --
file name of source

\item {} 
\textbf{sink} (\emph{str}) --
file name of sink

\end{itemize}

\item[{Returns}] \leavevmode
\emph{str} --
name of the copied file

\end{description}\end{quote}


\strong{See also:}


{\hyperref[api/ClearMap.IO:ClearMap.IO.IO.copyFile]{\emph{\code{copyFile()}}}}, {\hyperref[api/ClearMap.IO:ClearMap.IO.IO.convertData]{\emph{\code{convertData()}}}}



\end{fulllineitems}

\index{convertData() (in module ClearMap.IO.IO)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.IO:ClearMap.IO.IO.convertData}\pysiglinewithargsret{\bfcode{convertData}}{\emph{source}, \emph{sink}, \emph{**args}}{}
Transforms data from source format to sink format
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{source} (\emph{str}) --
file name of source

\item {} 
\textbf{sink} (\emph{str}) --
file name of sink

\end{itemize}

\item[{Returns}] \leavevmode
\emph{str} --
name of the copied file

\end{description}\end{quote}

\begin{notice}{warning}{Warning:}
Not optimized for large image data sets
\end{notice}


\strong{See also:}


{\hyperref[api/ClearMap.IO:ClearMap.IO.IO.copyFile]{\emph{\code{copyFile()}}}}, {\hyperref[api/ClearMap.IO:ClearMap.IO.IO.copyData]{\emph{\code{copyData()}}}}



\end{fulllineitems}

\index{toMultiChannelData() (in module ClearMap.IO.IO)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.IO:ClearMap.IO.IO.toMultiChannelData}\pysiglinewithargsret{\bfcode{toMultiChannelData}}{\emph{*args}}{}
Concatenate single channel arrays to one multi channel array
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{*args} (\emph{arrays}) --
arrays to be concatenated

\item[{Returns}] \leavevmode
\emph{array} --
concatenated multi-channel array

\end{description}\end{quote}

\end{fulllineitems}

\index{pointsToCoordinates() (in module ClearMap.IO.IO)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.IO:ClearMap.IO.IO.pointsToCoordinates}\pysiglinewithargsret{\bfcode{pointsToCoordinates}}{\emph{points}}{}
Converts a (coordiantes, properties) tuple to the coordinates only
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{points} (\emph{array or tuple}) --
point data to be reduced to coordinates

\item[{Returns}] \leavevmode
\emph{array} --
coordiante data

\end{description}\end{quote}
\paragraph{Notes}

Todo: Move this to a class that handles points and their meta data

\end{fulllineitems}

\index{pointsToProperties() (in module ClearMap.IO.IO)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.IO:ClearMap.IO.IO.pointsToProperties}\pysiglinewithargsret{\bfcode{pointsToProperties}}{\emph{points}}{}
Converts a (coordiante, properties) tuple to the properties only
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{points} (\emph{array or tuple}) --
point data to be reduced to properties

\item[{Returns}] \leavevmode
\emph{array} --
property data

\end{description}\end{quote}
\paragraph{Notes}

Todo: Move this to a class that handles points and their meta data

\end{fulllineitems}

\index{pointsToCoordinatesAndProperties() (in module ClearMap.IO.IO)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.IO:ClearMap.IO.IO.pointsToCoordinatesAndProperties}\pysiglinewithargsret{\bfcode{pointsToCoordinatesAndProperties}}{\emph{points}}{}
Converts points in various formats to a (coordinates, properties) tuple
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{points} (\emph{array or tuple}) --
point data to be converted to (coordinates, properties) tuple

\item[{Returns}] \leavevmode
\emph{tuple} --
(coordinates, properties) tuple

\end{description}\end{quote}
\paragraph{Notes}

Todo: Move this to a class that handles points and their meta data

\end{fulllineitems}

\index{pointsToCoordinatesAndPropertiesFileNames() (in module ClearMap.IO.IO)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.IO:ClearMap.IO.IO.pointsToCoordinatesAndPropertiesFileNames}\pysiglinewithargsret{\bfcode{pointsToCoordinatesAndPropertiesFileNames}}{\emph{filename}, \emph{propertiesPostfix='\_intensities'}, \emph{**args}}{}
Generates a tuple of filenames to store coordinates and properties data separately
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{filename} (\emph{str}) --
point data file name

\item {} 
\textbf{propertiesPostfix} (\emph{str}) --
postfix on file name to indicate property data

\end{itemize}

\item[{Returns}] \leavevmode
\emph{tuple} --
(file name, file name for properties)

\end{description}\end{quote}
\paragraph{Notes}

Todo: Move this to a class that handles points and their meta data

\end{fulllineitems}

\index{pointShiftFromRange() (in module ClearMap.IO.IO)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.IO:ClearMap.IO.IO.pointShiftFromRange}\pysiglinewithargsret{\bfcode{pointShiftFromRange}}{\emph{dataSize}, \emph{x=\textless{}built-in function all\textgreater{}}, \emph{y=\textless{}built-in function all\textgreater{}}, \emph{z=\textless{}built-in function all\textgreater{}}, \emph{**args}}{}
Calculate shift of points given a specific range restriction
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{dataSize} (\emph{str}) --
data size of the full image

\item {} 
\textbf{x,y,z} (\emph{tuples or all}) --
range specifications

\end{itemize}

\item[{Returns}] \leavevmode
\emph{tuple} --
shift of points from original origin of data to origin of range reduced data

\end{description}\end{quote}

\end{fulllineitems}

\index{pointsToRange() (in module ClearMap.IO.IO)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.IO:ClearMap.IO.IO.pointsToRange}\pysiglinewithargsret{\bfcode{pointsToRange}}{\emph{points}, \emph{dataSize=\textless{}built-in function all\textgreater{}}, \emph{x=\textless{}built-in function all\textgreater{}}, \emph{y=\textless{}built-in function all\textgreater{}}, \emph{z=\textless{}built-in function all\textgreater{}}, \emph{shift=False}, \emph{**args}}{}
Restrict points to a specific range
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{points} (\emph{array or str}) --
point source

\item {} 
\textbf{dataSize} (\emph{str}) --
data size of the full image

\item {} 
\textbf{x,y,z} (\emph{tuples or all}) --
range specifications

\item {} 
\textbf{shift} (\emph{bool}) --
shift points to relative coordinates in the reduced image

\end{itemize}

\item[{Returns}] \leavevmode
\emph{tuple} --
points reduced in range and optionally shifted to the range reduced origin

\end{description}\end{quote}

\end{fulllineitems}

\index{readPoints() (in module ClearMap.IO.IO)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.IO:ClearMap.IO.IO.readPoints}\pysiglinewithargsret{\bfcode{readPoints}}{\emph{source}, \emph{**args}}{}
Read a list of points from csv or vtk
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{source} (\emph{str, array, tuple or None}) --
the data source file

\item {} 
\textbf{**args} --
further arguments specific to point data format reader

\end{itemize}

\item[{Returns}] \leavevmode
\emph{array or tuple or None} --
point data of source

\end{description}\end{quote}


\strong{See also:}


{\hyperref[api/ClearMap.IO:ClearMap.IO.IO.writePoints]{\emph{\code{writePoints()}}}}



\end{fulllineitems}

\index{writePoints() (in module ClearMap.IO.IO)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.IO:ClearMap.IO.IO.writePoints}\pysiglinewithargsret{\bfcode{writePoints}}{\emph{sink}, \emph{points}, \emph{**args}}{}
Write a list of points to csv, vtk or ims files
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{sink} (\emph{str or None}) --
the destination for the point data

\item {} 
\textbf{points} (\emph{array or tuple or None}) --
the point data, optionally as (coordinates, properties) tuple

\item {} 
\textbf{**args} --
further arguments specific to point data format writer

\end{itemize}

\item[{Returns}] \leavevmode
\emph{str or array or tuple or None} --
point data of source

\end{description}\end{quote}


\strong{See also:}


{\hyperref[api/ClearMap.IO:ClearMap.IO.IO.readPoints]{\emph{\code{readPoints()}}}}



\end{fulllineitems}

\index{writeTable() (in module ClearMap.IO.IO)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.IO:ClearMap.IO.IO.writeTable}\pysiglinewithargsret{\bfcode{writeTable}}{\emph{filename}, \emph{table}}{}
Writes a numpy array with column names to a csv file.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{filename} (\emph{str}) --
filename to save table to

\item {} 
\textbf{table} (\emph{annotated array}) --
table to write to file

\end{itemize}

\item[{Returns}] \leavevmode
\emph{str} --
file name

\end{description}\end{quote}

\end{fulllineitems}



\paragraph{ClearMap.IO.CSV module}
\label{api/ClearMap.IO:clearmap-io-csv-module}\label{api/ClearMap.IO:module-ClearMap.IO.CSV}\index{ClearMap.IO.CSV (module)}
Interface to write csv files of cell coordinates / intensities

The module utilizes the csv file writer/reader from numpy.
\paragraph{Example}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{os}\PYG{o}{,} \PYG{n+nn}{numpy}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{ClearMap.IO.CSV} \PYG{k+kn}{as} \PYG{n+nn}{csv}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{ClearMap.Settings} \PYG{k+kn}{as} \PYG{n+nn}{settings}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{filename} \PYG{o}{=} \PYG{n}{os}\PYG{o}{.}\PYG{n}{path}\PYG{o}{.}\PYG{n}{join}\PYG{p}{(}\PYG{n}{settings}\PYG{o}{.}\PYG{n}{ClearMapPath}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Test/ImageProcessing/points.txt}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{points} \PYG{o}{=} \PYG{n}{numpy}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{rand}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{;}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{csv}\PYG{o}{.}\PYG{n}{writePoints}\PYG{p}{(}\PYG{n}{filename}\PYG{p}{,} \PYG{n}{points}\PYG{p}{)}\PYG{p}{;}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{points2} \PYG{o}{=} \PYG{n}{csv}\PYG{o}{.}\PYG{n}{readPoints}\PYG{p}{(}\PYG{n}{filename}\PYG{p}{)}\PYG{p}{;}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print} \PYG{n}{points2}\PYG{o}{.}\PYG{n}{shape}
\PYG{g+go}{(5, 3)}
\end{Verbatim}
\index{writePoints() (in module ClearMap.IO.CSV)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.IO:ClearMap.IO.CSV.writePoints}\pysiglinewithargsret{\bfcode{writePoints}}{\emph{filename}, \emph{points}, \emph{**args}}{}
Write point data to csv file
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{filename} (\emph{str}) --
file name

\item {} 
\textbf{points} (\emph{array}) --
point data

\end{itemize}

\item[{Returns}] \leavevmode
\emph{str} --
file name

\end{description}\end{quote}

\end{fulllineitems}

\index{readPoints() (in module ClearMap.IO.CSV)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.IO:ClearMap.IO.CSV.readPoints}\pysiglinewithargsret{\bfcode{readPoints}}{\emph{filename}, \emph{**args}}{}
Read point data to csv file
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{filename} (\emph{str}) --
file name

\item {} 
\textbf{**args} --
arguments for \code{pointsToRange()}

\end{itemize}

\item[{Returns}] \leavevmode
\emph{str} --
file name

\end{description}\end{quote}

\end{fulllineitems}

\index{test() (in module ClearMap.IO.CSV)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.IO:ClearMap.IO.CSV.test}\pysiglinewithargsret{\bfcode{test}}{}{}
Test CSV module

\end{fulllineitems}



\paragraph{ClearMap.IO.FileList module}
\label{api/ClearMap.IO:module-ClearMap.IO.FileList}\label{api/ClearMap.IO:clearmap-io-filelist-module}\index{ClearMap.IO.FileList (module)}
Interface to read/write image stacks saved as a list of files

The filename is given as regular expression as described
\href{https://docs.python.org/2/library/re.html}{here}.

It is assumd that there is a single digit like regular expression in the file
name, i.e. \code{\textbackslash{}d\{4\}} indicates a placeholder for an integer with four digits using traling 0s
and \code{\textbackslash{}d\{\}} would jus asume an integer with variable size.

For example: \code{/test\textbackslash{}d\{4\}.tif} or  \code{/test\textbackslash{}d\{\}.tif}
\paragraph{Examples}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{os}\PYG{o}{,} \PYG{n+nn}{numpy}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{ClearMap.Settings} \PYG{k+kn}{as} \PYG{n+nn}{settings}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{ClearMap.IO.FileList} \PYG{k+kn}{as} \PYG{n+nn}{fl}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{filename} \PYG{o}{=} \PYG{n}{os}\PYG{o}{.}\PYG{n}{path}\PYG{o}{.}\PYG{n}{join}\PYG{p}{(}\PYG{n}{settings}\PYG{o}{.}\PYG{n}{ClearMapPath}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Test/Data/FileList/test}\PYG{l+s}{\PYGZbs{}}\PYG{l+s}{d\PYGZob{}4\PYGZcb{}.tif}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{data} \PYG{o}{=} \PYG{n}{numpy}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{rand}\PYG{p}{(}\PYG{l+m+mi}{20}\PYG{p}{,}\PYG{l+m+mi}{50}\PYG{p}{,}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{;}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{data} \PYG{o}{=} \PYG{n}{data}\PYG{o}{.}\PYG{n}{astype}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{int32}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{fl}\PYG{o}{.}\PYG{n}{writeData}\PYG{p}{(}\PYG{n}{filename}\PYG{p}{,} \PYG{n}{data}\PYG{p}{)}\PYG{p}{;}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{img} \PYG{o}{=} \PYG{n}{fl}\PYG{o}{.}\PYG{n}{readData}\PYG{p}{(}\PYG{n}{filename}\PYG{p}{)}\PYG{p}{;}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print} \PYG{n}{img}\PYG{o}{.}\PYG{n}{shape}
\PYG{g+go}{(20, 50, 10)}
\end{Verbatim}
\index{readFileList() (in module ClearMap.IO.FileList)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.IO:ClearMap.IO.FileList.readFileList}\pysiglinewithargsret{\bfcode{readFileList}}{\emph{filename}}{}
Returns list of files that match the regular expression
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{filename} (\emph{str}) --
file name as regular expression

\item[{Returns}] \leavevmode
\emph{str, list} --
path of files, file names that match the regular expression

\end{description}\end{quote}

\end{fulllineitems}

\index{splitFileExpression() (in module ClearMap.IO.FileList)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.IO:ClearMap.IO.FileList.splitFileExpression}\pysiglinewithargsret{\bfcode{splitFileExpression}}{\emph{filename}}{}
Split the regular expression at the digit place holder
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{filename} (\emph{str}) --
file name as regular expression

\item[{Returns}] \leavevmode
\emph{tuple} --
file header, file extension, digit format

\end{description}\end{quote}

\end{fulllineitems}

\index{fileExperssionToFileName() (in module ClearMap.IO.FileList)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.IO:ClearMap.IO.FileList.fileExperssionToFileName}\pysiglinewithargsret{\bfcode{fileExperssionToFileName}}{\emph{filename}, \emph{z}}{}
Insert a number into the regular expression
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{filename} (\emph{str}) --
file name as regular expression

\item {} 
\textbf{z} (\emph{int}) --
z slice index

\end{itemize}

\item[{Returns}] \leavevmode
\emph{str} --
file name

\end{description}\end{quote}

\end{fulllineitems}

\index{dataSize() (in module ClearMap.IO.FileList)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.IO:ClearMap.IO.FileList.dataSize}\pysiglinewithargsret{\bfcode{dataSize}}{\emph{filename}, \emph{**args}}{}
Returns size of data stored as a file list
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{filename} (\emph{str}) --
file name as regular expression

\item {} 
\textbf{x,y,z} (\emph{tuple}) --
data range specifications

\end{itemize}

\item[{Returns}] \leavevmode
\emph{tuple} --
data size

\end{description}\end{quote}

\end{fulllineitems}

\index{dataZSize() (in module ClearMap.IO.FileList)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.IO:ClearMap.IO.FileList.dataZSize}\pysiglinewithargsret{\bfcode{dataZSize}}{\emph{filename}, \emph{z=\textless{}built-in function all\textgreater{}}, \emph{**args}}{}
Returns size of data stored as a file list
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{filename} (\emph{str}) --
file name as regular expression

\item {} 
\textbf{z} (\emph{tuple}) --
z data range specification

\end{itemize}

\item[{Returns}] \leavevmode
\emph{int} --
z data size

\end{description}\end{quote}

\end{fulllineitems}

\index{readDataFiles() (in module ClearMap.IO.FileList)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.IO:ClearMap.IO.FileList.readDataFiles}\pysiglinewithargsret{\bfcode{readDataFiles}}{\emph{filename}, \emph{x=\textless{}built-in function all\textgreater{}}, \emph{y=\textless{}built-in function all\textgreater{}}, \emph{z=\textless{}built-in function all\textgreater{}}, \emph{**args}}{}
Read data from individual images assuming they are the z slices
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{filename} (\emph{str}) --
file name as regular expression

\item {} 
\textbf{x,y,z} (\emph{tuple}) --
data range specifications

\end{itemize}

\item[{Returns}] \leavevmode
\emph{array} --
image data

\end{description}\end{quote}

\end{fulllineitems}

\index{readData() (in module ClearMap.IO.FileList)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.IO:ClearMap.IO.FileList.readData}\pysiglinewithargsret{\bfcode{readData}}{\emph{filename}, \emph{**args}}{}
Read image stack from single or multiple images
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{filename} (\emph{str}) --
file name as regular expression

\item {} 
\textbf{x,y,z} (\emph{tuple}) --
data range specifications

\end{itemize}

\item[{Returns}] \leavevmode
\emph{array} --
image data

\end{description}\end{quote}

\end{fulllineitems}

\index{writeData() (in module ClearMap.IO.FileList)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.IO:ClearMap.IO.FileList.writeData}\pysiglinewithargsret{\bfcode{writeData}}{\emph{filename}, \emph{data}, \emph{startIndex=0}}{}
Write image stack to single or multiple image files
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{filename} (\emph{str}) --
file name as regular expression

\item {} 
\textbf{data} (\emph{array}) --
image data

\item {} 
\textbf{startIndex} (\emph{int}) --
index of first z-slice

\end{itemize}

\item[{Returns}] \leavevmode
\emph{str} --
file name as regular expression

\end{description}\end{quote}

\end{fulllineitems}

\index{copyData() (in module ClearMap.IO.FileList)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.IO:ClearMap.IO.FileList.copyData}\pysiglinewithargsret{\bfcode{copyData}}{\emph{source}, \emph{sink}}{}
Copy a data file from source to sink when for entire list of files
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{source} (\emph{str}) --
file name pattern of source

\item {} 
\textbf{sink} (\emph{str}) --
file name pattern of sink

\end{itemize}

\item[{Returns}] \leavevmode
\emph{str} --
file name patttern of the copy

\end{description}\end{quote}

\end{fulllineitems}

\index{test() (in module ClearMap.IO.FileList)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.IO:ClearMap.IO.FileList.test}\pysiglinewithargsret{\bfcode{test}}{}{}
Test FileList module

\end{fulllineitems}



\paragraph{ClearMap.IO.Imaris module}
\label{api/ClearMap.IO:clearmap-io-imaris-module}\label{api/ClearMap.IO:module-ClearMap.IO.Imaris}\index{ClearMap.IO.Imaris (module)}
Interface to Imaris Files

Module to read data and write points to \href{http://www.bitplane.com/imaris/imaris}{Imaris}
files.

\begin{notice}{note}{Note:}
To write points without errors make sure the original file has at least one spot object!
\end{notice}
\paragraph{Example}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{os}\PYG{o}{,} \PYG{n+nn}{numpy}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{ClearMap.IO.Imaris} \PYG{k+kn}{as} \PYG{n+nn}{ims}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{ClearMap.Settings} \PYG{k+kn}{import} \PYG{n}{ClearMapPath}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{filename} \PYG{o}{=} \PYG{n}{os}\PYG{o}{.}\PYG{n}{path}\PYG{o}{.}\PYG{n}{join}\PYG{p}{(}\PYG{n}{ClearMapPath}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Test/Data/Imaris/test for spots added spot.ims}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{ims}\PYG{o}{.}\PYG{n}{dataSize}\PYG{p}{(}\PYG{n}{filename}\PYG{p}{)}\PYG{p}{;}
\PYG{g+go}{(256, 320, 256)}
\end{Verbatim}
\begin{description}
\item[{Todo:}] \leavevmode\begin{itemize}
\item {} 
Fix writing new spots to imaris file

\item {} 
Get settings to directly render points as `pixel' and not as spheres

\end{itemize}

\end{description}

Author
\begin{quote}

Chirstoph Kirst, The Rockefeller University, New York City, 2015
\end{quote}
\index{openFile() (in module ClearMap.IO.Imaris)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.IO:ClearMap.IO.Imaris.openFile}\pysiglinewithargsret{\bfcode{openFile}}{\emph{filename}, \emph{mode='a'}}{}
Open Imaris file as hdf5 object
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{filename} (\emph{str}) --
file name

\item {} 
\textbf{mode} (\emph{str}) --
argument to h5py.File

\end{itemize}

\item[{Returns}] \leavevmode
\emph{object} --
h5py object

\end{description}\end{quote}

\end{fulllineitems}

\index{closeFile() (in module ClearMap.IO.Imaris)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.IO:ClearMap.IO.Imaris.closeFile}\pysiglinewithargsret{\bfcode{closeFile}}{\emph{h5file}}{}
Close Imaris hdf5 file object
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{h5file} (\emph{object}) --
h5py opject

\item[{Returns}] \leavevmode
\emph{bool} --
success

\end{description}\end{quote}

\end{fulllineitems}

\index{readDataSet() (in module ClearMap.IO.Imaris)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.IO:ClearMap.IO.Imaris.readDataSet}\pysiglinewithargsret{\bfcode{readDataSet}}{\emph{h5file}, \emph{resolution=0}, \emph{channel=0}, \emph{timepoint=0}}{}
Open Imaris file and returns hdf5 image data
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{h5file} (\emph{object}) --
h5py object

\item {} 
\textbf{resolution} (\emph{int}) --
resolution level

\item {} 
\textbf{channel} (\emph{int}) --
color channel

\item {} 
\textbf{timepoint} (\emph{int}) --
time point

\end{itemize}

\item[{Returns}] \leavevmode
\emph{array} --
image data

\end{description}\end{quote}

\end{fulllineitems}

\index{dataSize() (in module ClearMap.IO.Imaris)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.IO:ClearMap.IO.Imaris.dataSize}\pysiglinewithargsret{\bfcode{dataSize}}{\emph{filename}, \emph{resolution=0}, \emph{channel=0}, \emph{timepoint=0}, \emph{**args}}{}
Read data size of the imaris image data set
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{filename} (\emph{str}) --
imaris file name

\item {} 
\textbf{resolution} (\emph{int}) --
resolution level

\item {} 
\textbf{channel} (\emph{int}) --
color channel

\item {} 
\textbf{timepoint} (\emph{int}) --
time point

\end{itemize}

\item[{Returns}] \leavevmode
\emph{tuple} --
image data size

\end{description}\end{quote}

\end{fulllineitems}

\index{dataZSize() (in module ClearMap.IO.Imaris)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.IO:ClearMap.IO.Imaris.dataZSize}\pysiglinewithargsret{\bfcode{dataZSize}}{\emph{filename}, \emph{**args}}{}
Read z data size of the imaris image data set
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{filename} (\emph{str}) --
imaris file name

\item {} 
\textbf{resolution} (\emph{int}) --
resolution level

\item {} 
\textbf{channel} (\emph{int}) --
color channel

\item {} 
\textbf{timepoint} (\emph{int}) --
time point

\end{itemize}

\item[{Returns}] \leavevmode
\emph{int} --
image z data size

\end{description}\end{quote}

\end{fulllineitems}

\index{readData() (in module ClearMap.IO.Imaris)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.IO:ClearMap.IO.Imaris.readData}\pysiglinewithargsret{\bfcode{readData}}{\emph{filename}, \emph{x=\textless{}built-in function all\textgreater{}}, \emph{y=\textless{}built-in function all\textgreater{}}, \emph{z=\textless{}built-in function all\textgreater{}}, \emph{resolution=0}, \emph{channel=0}, \emph{timepoint=0}, \emph{**args}}{}
Read data from imaris file
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{filename} (\emph{str}) --
file name as regular expression

\item {} 
\textbf{x,y,z} (\emph{tuple}) --
data range specifications

\item {} 
\textbf{resolution} (\emph{int}) --
resolution level

\item {} 
\textbf{channel} (\emph{int}) --
color channel

\item {} 
\textbf{timepoint} (\emph{int}) --
time point

\end{itemize}

\item[{Returns}] \leavevmode
\emph{array} --
image data

\end{description}\end{quote}

\end{fulllineitems}

\index{getDataSize() (in module ClearMap.IO.Imaris)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.IO:ClearMap.IO.Imaris.getDataSize}\pysiglinewithargsret{\bfcode{getDataSize}}{\emph{h5file}}{}
Get the full data size in pixel from h5py imaris object
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{h5file} (\emph{object}) --
h5py object

\item[{Returns}] \leavevmode
\emph{tuple} --
image data size

\end{description}\end{quote}

\end{fulllineitems}

\index{getDataExtent() (in module ClearMap.IO.Imaris)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.IO:ClearMap.IO.Imaris.getDataExtent}\pysiglinewithargsret{\bfcode{getDataExtent}}{\emph{h5file}}{}
Get the spatial extent of data from h5py imaris object
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{h5file} (\emph{object}) --
h5py object

\item[{Returns}] \leavevmode
\emph{array} --
spatial extend of image

\end{description}\end{quote}

\end{fulllineitems}

\index{getScaleAndOffset() (in module ClearMap.IO.Imaris)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.IO:ClearMap.IO.Imaris.getScaleAndOffset}\pysiglinewithargsret{\bfcode{getScaleAndOffset}}{\emph{h5file}}{}
Determine scale and offset to transform pixel to spatial coordinates as used by imaris
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{h5file} (\emph{object}) --
h5py object

\item[{Returns}] \leavevmode
\emph{tuple} --
image scale (length / pixel) and offset (from origin)

\end{description}\end{quote}

\end{fulllineitems}

\index{transformPointsToImaris() (in module ClearMap.IO.Imaris)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.IO:ClearMap.IO.Imaris.transformPointsToImaris}\pysiglinewithargsret{\bfcode{transformPointsToImaris}}{\emph{points}, \emph{scale=(4.0625}, \emph{4.0625}, \emph{3)}, \emph{offset=(0}, \emph{0}, \emph{0)}}{}
Transform pixel coordinates of cell centers to work in Imaris
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{points} (\emph{array}) --
point coordinate array

\item {} 
\textbf{scale} (\emph{tuple}) --
spatial scale of the image data

\item {} 
\textbf{offset} (\emph{tuple}) --
spatial offset of the image data

\end{itemize}

\item[{Returns}] \leavevmode
\emph{array} --
scaled points

\end{description}\end{quote}

\end{fulllineitems}

\index{writePoints() (in module ClearMap.IO.Imaris)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.IO:ClearMap.IO.Imaris.writePoints}\pysiglinewithargsret{\bfcode{writePoints}}{\emph{filename}, \emph{points}, \emph{mode='o'}, \emph{radius=0.5}, \emph{scale=\textless{}built-in function all\textgreater{}}, \emph{offset=None}}{}
Write points to Imaris file
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{filename} (\emph{str}) --
imaris file name

\item {} 
\textbf{points} (\emph{array}) --
point data

\item {} 
\textbf{mode} (\emph{str}) --
`o'= override, `a'=add

\item {} 
\textbf{radius} (\emph{float}) --
size of each point

\item {} 
\textbf{scale} (\emph{tuple or all}) --
spatial scaling of points

\item {} 
\textbf{offset} (\emph{tuple or None}) --
spatial offset of points

\end{itemize}

\item[{Returns}] \leavevmode
\emph{str} --
file name of imaris file

\end{description}\end{quote}

\begin{notice}{note}{Note:}
This routine is still experimental !
\end{notice}

\end{fulllineitems}

\index{writeData() (in module ClearMap.IO.Imaris)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.IO:ClearMap.IO.Imaris.writeData}\pysiglinewithargsret{\bfcode{writeData}}{\emph{filename}, \emph{**args}}{}
Write image data to imaris file

\begin{notice}{note}{Note:}
Not implemented yet !
\end{notice}

\end{fulllineitems}

\index{readPoints() (in module ClearMap.IO.Imaris)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.IO:ClearMap.IO.Imaris.readPoints}\pysiglinewithargsret{\bfcode{readPoints}}{\emph{filename}}{}
Read points from imaris file

\begin{notice}{note}{Note:}
Not implemented yet !
\end{notice}

\end{fulllineitems}

\index{copyData() (in module ClearMap.IO.Imaris)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.IO:ClearMap.IO.Imaris.copyData}\pysiglinewithargsret{\bfcode{copyData}}{\emph{source}, \emph{sink}}{}
Copy a imaris file from source to sink
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{source} (\emph{str}) --
file name pattern of source

\item {} 
\textbf{sink} (\emph{str}) --
file name pattern of sink

\end{itemize}

\item[{Returns}] \leavevmode
\emph{str} --
file name patttern of the copy

\end{description}\end{quote}

\end{fulllineitems}

\index{test() (in module ClearMap.IO.Imaris)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.IO:ClearMap.IO.Imaris.test}\pysiglinewithargsret{\bfcode{test}}{}{}
Test Imaris module

\end{fulllineitems}



\paragraph{ClearMap.IO.NPY module}
\label{api/ClearMap.IO:clearmap-io-npy-module}\label{api/ClearMap.IO:module-ClearMap.IO.NPY}\index{ClearMap.IO.NPY (module)}
Interface to write binary files for point like data

The interface is based on the numpy library.
\paragraph{Example}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{os}\PYG{o}{,} \PYG{n+nn}{numpy}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{ClearMap.Settings} \PYG{k+kn}{as} \PYG{n+nn}{settings}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{ClearMap.IO.NPY} \PYG{k+kn}{as} \PYG{n+nn}{npy}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{filename} \PYG{o}{=} \PYG{n}{os}\PYG{o}{.}\PYG{n}{path}\PYG{o}{.}\PYG{n}{join}\PYG{p}{(}\PYG{n}{settings}\PYG{o}{.}\PYG{n}{ClearMapPath}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Test/Data/NPY/points.npy}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{points} \PYG{o}{=} \PYG{n}{npy}\PYG{o}{.}\PYG{n}{readPoints}\PYG{p}{(}\PYG{n}{filename}\PYG{p}{)}\PYG{p}{;}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print} \PYG{n}{points}\PYG{o}{.}\PYG{n}{shape}
\PYG{g+go}{(5, 3)}
\end{Verbatim}

Author
\begin{quote}

Christoph Kirst, The Rockefeller University, New York City, 2015
\end{quote}
\index{writePoints() (in module ClearMap.IO.NPY)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.IO:ClearMap.IO.NPY.writePoints}\pysiglinewithargsret{\bfcode{writePoints}}{\emph{filename}, \emph{points}, \emph{**args}}{}
\end{fulllineitems}

\index{readPoints() (in module ClearMap.IO.NPY)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.IO:ClearMap.IO.NPY.readPoints}\pysiglinewithargsret{\bfcode{readPoints}}{\emph{filename}, \emph{**args}}{}
\end{fulllineitems}

\index{test() (in module ClearMap.IO.NPY)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.IO:ClearMap.IO.NPY.test}\pysiglinewithargsret{\bfcode{test}}{}{}
Test NPY module

\end{fulllineitems}



\paragraph{ClearMap.IO.NRRD module}
\label{api/ClearMap.IO:clearmap-io-nrrd-module}\phantomsection\label{api/ClearMap.IO:module-ClearMap.IO.NRRD}\index{ClearMap.IO.NRRD (module)}
Interface to NRRD volumetric image data files.

The interface is based on nrrd.py, an all-python (and numpy)
implementation for reading and writing nrrd files.
See \href{http://teem.sourceforge.net/nrrd/format.html}{http://teem.sourceforge.net/nrrd/format.html} for the specification.
\paragraph{Example}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{os}\PYG{o}{,} \PYG{n+nn}{numpy}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{ClearMap.Settings} \PYG{k+kn}{as} \PYG{n+nn}{settings}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{ClearMap.IO.NRRD} \PYG{k+kn}{as} \PYG{n+nn}{nrrd}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{filename} \PYG{o}{=} \PYG{n}{os}\PYG{o}{.}\PYG{n}{path}\PYG{o}{.}\PYG{n}{join}\PYG{p}{(}\PYG{n}{settings}\PYG{o}{.}\PYG{n}{ClearMapPath}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Test/Data/Nrrd/test.nrrd}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{data} \PYG{o}{=} \PYG{n}{nrrd}\PYG{o}{.}\PYG{n}{readData}\PYG{p}{(}\PYG{n}{filename}\PYG{p}{)}\PYG{p}{;}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print} \PYG{n}{data}\PYG{o}{.}\PYG{n}{shape}
\PYG{g+go}{(20, 50, 10)}
\end{Verbatim}

Author
\begin{quote}

Copyright 2011 Maarten Everts and David Hammond.

Modified to integrate into ClearMap framework:
- Christoph Kirst, The Rockefeller University, New York City, 2015
\end{quote}
\index{NrrdError}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.IO:ClearMap.IO.NRRD.NrrdError}\pysigline{\strong{exception }\bfcode{NrrdError}}
Bases: \code{exceptions.Exception}

Exceptions for Nrrd class.

\end{fulllineitems}

\index{parse\_nrrdvector() (in module ClearMap.IO.NRRD)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.IO:ClearMap.IO.NRRD.parse_nrrdvector}\pysiglinewithargsret{\bfcode{parse\_nrrdvector}}{\emph{inp}}{}
Parse a vector from a nrrd header, return a list.

\end{fulllineitems}

\index{parse\_optional\_nrrdvector() (in module ClearMap.IO.NRRD)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.IO:ClearMap.IO.NRRD.parse_optional_nrrdvector}\pysiglinewithargsret{\bfcode{parse\_optional\_nrrdvector}}{\emph{inp}}{}
Parse a vector from a nrrd header that can also be none.

\end{fulllineitems}

\index{readHeader() (in module ClearMap.IO.NRRD)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.IO:ClearMap.IO.NRRD.readHeader}\pysiglinewithargsret{\bfcode{readHeader}}{\emph{filename}}{}
Parse the fields in the nrrd header

nrrdfile can be any object which supports the iterator protocol and
returns a string each time its next() method is called  file objects and
list objects are both suitable. If csvfile is a file object, it must be
opened with the b flag on platforms where that makes a difference
(e.g. Windows)

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{readHeader}\PYG{p}{(}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{NRRD0005}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{type: float}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{dimension: 3}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}
\PYG{g+go}{\PYGZob{}\PYGZsq{}type\PYGZsq{}: \PYGZsq{}float\PYGZsq{}, \PYGZsq{}dimension\PYGZsq{}: 3, \PYGZsq{}keyvaluepairs\PYGZsq{}: \PYGZob{}\PYGZcb{}\PYGZcb{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{readHeader}\PYG{p}{(}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{NRRD0005}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{my extra info:=my : colon\PYGZhy{}separated : values}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}
\PYG{g+go}{\PYGZob{}\PYGZsq{}keyvaluepairs\PYGZsq{}: \PYGZob{}\PYGZsq{}my extra info\PYGZsq{}: \PYGZsq{}my : colon\PYGZhy{}separated : values\PYGZsq{}\PYGZcb{}\PYGZcb{}}
\end{Verbatim}

\end{fulllineitems}

\index{readData() (in module ClearMap.IO.NRRD)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.IO:ClearMap.IO.NRRD.readData}\pysiglinewithargsret{\bfcode{readData}}{\emph{filename}, \emph{**args}}{}
Read nrrd file image data
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{filename} (\emph{str}) --
file name as regular expression

\item {} 
\textbf{x,y,z} (\emph{tuple}) --
data range specifications

\end{itemize}

\item[{Returns}] \leavevmode
\emph{array} --
image data

\end{description}\end{quote}

\end{fulllineitems}

\index{writeData() (in module ClearMap.IO.NRRD)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.IO:ClearMap.IO.NRRD.writeData}\pysiglinewithargsret{\bfcode{writeData}}{\emph{filename}, \emph{data}, \emph{options=\{\}}, \emph{separateHeader=False}}{}
Write data to nrrd file
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{filename} (\emph{str}) --
file name as regular expression

\item {} 
\textbf{data} (\emph{array}) --
image data

\item {} 
\textbf{options} (\emph{dict}) --
options dictionary

\item {} 
\textbf{separateHeader} (\emph{bool}) --
write a separate header file

\end{itemize}

\item[{Returns}] \leavevmode
\emph{str} --
nrrd output file name

\end{description}\end{quote}

To sample date use \emph{options{[}'spacings'{]} = {[}s1, s2, s3{]}} for
3d data with sampling deltas \emph{s1}, \emph{s2}, and \emph{s3} in each dimension.

\end{fulllineitems}

\index{dataSize() (in module ClearMap.IO.NRRD)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.IO:ClearMap.IO.NRRD.dataSize}\pysiglinewithargsret{\bfcode{dataSize}}{\emph{filename}, \emph{**args}}{}
Read data size from nrrd image
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{filename} (\emph{str}) --
file name as regular expression

\item {} 
\textbf{x,y,z} (\emph{tuple}) --
data range specifications

\end{itemize}

\item[{Returns}] \leavevmode
\emph{tuple} --
data size

\end{description}\end{quote}

\end{fulllineitems}

\index{dataZSize() (in module ClearMap.IO.NRRD)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.IO:ClearMap.IO.NRRD.dataZSize}\pysiglinewithargsret{\bfcode{dataZSize}}{\emph{filename}, \emph{z=\textless{}built-in function all\textgreater{}}, \emph{**args}}{}
Read data z size from nrrd image
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{filename} (\emph{str}) --
file name as regular expression

\item {} 
\textbf{z} (\emph{tuple}) --
z data range specification

\end{itemize}

\item[{Returns}] \leavevmode
\emph{int} --
z data size

\end{description}\end{quote}

\end{fulllineitems}

\index{copyData() (in module ClearMap.IO.NRRD)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.IO:ClearMap.IO.NRRD.copyData}\pysiglinewithargsret{\bfcode{copyData}}{\emph{source}, \emph{sink}}{}
Copy an nrrd file from source to sink
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{source} (\emph{str}) --
file name pattern of source

\item {} 
\textbf{sink} (\emph{str}) --
file name pattern of sink

\end{itemize}

\item[{Returns}] \leavevmode
\emph{str} --
file name of the copy

\end{description}\end{quote}
\paragraph{Notes}

Todo: dealt with nrdh header files!

\end{fulllineitems}

\index{test() (in module ClearMap.IO.NRRD)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.IO:ClearMap.IO.NRRD.test}\pysiglinewithargsret{\bfcode{test}}{}{}
Test NRRD IO module

\end{fulllineitems}



\paragraph{ClearMap.IO.RAW module}
\label{api/ClearMap.IO:clearmap-io-raw-module}\label{api/ClearMap.IO:module-ClearMap.IO.RAW}\index{ClearMap.IO.RAW (module)}
Simple Interface to read RAW/MHD files e.g. created by elastix

Todo: read subsets efficiently
\paragraph{Example}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{os}\PYG{o}{,} \PYG{n+nn}{numpy}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{ClearMap.Settings} \PYG{k+kn}{import} \PYG{n}{ClearMapPath}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{ClearMap.IO.RAW} \PYG{k+kn}{as} \PYG{n+nn}{raw}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{filename} \PYG{o}{=} \PYG{n}{os}\PYG{o}{.}\PYG{n}{path}\PYG{o}{.}\PYG{n}{join}\PYG{p}{(}\PYG{n}{ClearMapPath}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Test/Data/Raw/test.mhd}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{raw}\PYG{o}{.}\PYG{n}{dataSize}\PYG{p}{(}\PYG{n}{filename}\PYG{p}{)}\PYG{p}{;}
\PYG{g+go}{(20, 50, 10)}
\end{Verbatim}

Author
\begin{quote}

Christoph Kirst, The Rockefeller University, New York City, 2015
\end{quote}
\index{dataSize() (in module ClearMap.IO.RAW)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.IO:ClearMap.IO.RAW.dataSize}\pysiglinewithargsret{\bfcode{dataSize}}{\emph{filename}, \emph{**args}}{}
Read data size from raw/mhd image
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{filename} (\emph{str}) --
imaris file name

\item {} 
\textbf{x,y,z} (\emph{tuple or all}) --
range specifications

\end{itemize}

\item[{Returns}] \leavevmode
\emph{int} --
raw image data size

\end{description}\end{quote}

\end{fulllineitems}

\index{dataZSize() (in module ClearMap.IO.RAW)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.IO:ClearMap.IO.RAW.dataZSize}\pysiglinewithargsret{\bfcode{dataZSize}}{\emph{filename}, \emph{z=\textless{}built-in function all\textgreater{}}, \emph{**args}}{}
Read z data size from raw/mhd image
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{filename} (\emph{str}) --
imaris file name

\item {} 
\textbf{z} (\emph{tuple or all}) --
range specification

\end{itemize}

\item[{Returns}] \leavevmode
\emph{int} --
raw image z data size

\end{description}\end{quote}

\end{fulllineitems}

\index{readData() (in module ClearMap.IO.RAW)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.IO:ClearMap.IO.RAW.readData}\pysiglinewithargsret{\bfcode{readData}}{\emph{filename}, \emph{x=\textless{}built-in function all\textgreater{}}, \emph{y=\textless{}built-in function all\textgreater{}}, \emph{z=\textless{}built-in function all\textgreater{}}}{}
Read data from raw/mhd image
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{filename} (\emph{str}) --
file name as regular expression

\item {} 
\textbf{x,y,z} (\emph{tuple}) --
data range specifications

\end{itemize}

\item[{Returns}] \leavevmode
\emph{array} --
image data

\end{description}\end{quote}

\end{fulllineitems}

\index{writeHeader() (in module ClearMap.IO.RAW)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.IO:ClearMap.IO.RAW.writeHeader}\pysiglinewithargsret{\bfcode{writeHeader}}{\emph{filename}, \emph{meta\_dict}}{}
Write raw header mhd file
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{filename} (\emph{str}) --
file name of header

\item {} 
\textbf{meta\_dict} (\emph{dict}) --
dictionary of meta data

\end{itemize}

\item[{Returns}] \leavevmode
\emph{str} --
header file name

\end{description}\end{quote}

\end{fulllineitems}

\index{writeRawData() (in module ClearMap.IO.RAW)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.IO:ClearMap.IO.RAW.writeRawData}\pysiglinewithargsret{\bfcode{writeRawData}}{\emph{filename}, \emph{data}}{}
Write the data into a raw format file.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{filename} (\emph{str}) --
file name as regular expression

\item {} 
\textbf{data} (\emph{array}) --
data to write to raw file

\end{itemize}

\item[{Returns}] \leavevmode
\emph{str} --
file name of raw file

\end{description}\end{quote}

\end{fulllineitems}

\index{writeData() (in module ClearMap.IO.RAW)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.IO:ClearMap.IO.RAW.writeData}\pysiglinewithargsret{\bfcode{writeData}}{\emph{filename}, \emph{data}, \emph{**args}}{}
Write  data into to raw/mhd file pair
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{filename} (\emph{str}) --
file name as regular expression

\item {} 
\textbf{data} (\emph{array}) --
data to write to raw file

\end{itemize}

\item[{Returns}] \leavevmode
\emph{str} --
file name of mhd file

\end{description}\end{quote}

\end{fulllineitems}

\index{copyData() (in module ClearMap.IO.RAW)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.IO:ClearMap.IO.RAW.copyData}\pysiglinewithargsret{\bfcode{copyData}}{\emph{source}, \emph{sink}}{}
Copy a raw/mhd file pair from source to sink
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{source} (\emph{str}) --
file name of source

\item {} 
\textbf{sink} (\emph{str}) --
file name of sink

\end{itemize}

\item[{Returns}] \leavevmode
\emph{str} --
file name of the copy

\end{description}\end{quote}

\end{fulllineitems}

\index{test() (in module ClearMap.IO.RAW)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.IO:ClearMap.IO.RAW.test}\pysiglinewithargsret{\bfcode{test}}{}{}
Test RAW io module

\end{fulllineitems}



\paragraph{ClearMap.IO.TIF module}
\label{api/ClearMap.IO:clearmap-io-tif-module}\label{api/ClearMap.IO:module-ClearMap.IO.TIF}\index{ClearMap.IO.TIF (module)}
Interface to tif image files and stacks.

The interface makes use of the tifffile library.
\paragraph{Example}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{os}\PYG{o}{,} \PYG{n+nn}{numpy}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{ClearMap.IO.TIF} \PYG{k+kn}{as} \PYG{n+nn}{tif}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{ClearMap.Settings} \PYG{k+kn}{import} \PYG{n}{ClearMapPath}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{filename} \PYG{o}{=} \PYG{n}{os}\PYG{o}{.}\PYG{n}{path}\PYG{o}{.}\PYG{n}{join}\PYG{p}{(}\PYG{n}{ClearMapPath}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Test/Data/Tif/composite.tif}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{data} \PYG{o}{=} \PYG{n}{tif}\PYG{o}{.}\PYG{n}{readData}\PYG{p}{(}\PYG{n}{filename}\PYG{p}{)}\PYG{p}{;}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print} \PYG{n}{data}\PYG{o}{.}\PYG{n}{shape}
\PYG{g+go}{(50, 100, 30, 4)}
\end{Verbatim}

Author
\begin{quote}

Christoph Kirst, The Rockefeller University, New York City, 2015
\end{quote}
\index{dataSize() (in module ClearMap.IO.TIF)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.IO:ClearMap.IO.TIF.dataSize}\pysiglinewithargsret{\bfcode{dataSize}}{\emph{filename}, \emph{**args}}{}
Returns size of data in tif file
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{filename} (\emph{str}) --
file name as regular expression

\item {} 
\textbf{x,y,z} (\emph{tuple}) --
data range specifications

\end{itemize}

\item[{Returns}] \leavevmode
\emph{tuple} --
data size

\end{description}\end{quote}

\end{fulllineitems}

\index{dataZSize() (in module ClearMap.IO.TIF)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.IO:ClearMap.IO.TIF.dataZSize}\pysiglinewithargsret{\bfcode{dataZSize}}{\emph{filename}, \emph{z=\textless{}built-in function all\textgreater{}}, \emph{**args}}{}
Returns z size of data in tif file
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{filename} (\emph{str}) --
file name as regular expression

\item {} 
\textbf{z} (\emph{tuple}) --
z data range specification

\end{itemize}

\item[{Returns}] \leavevmode
\emph{int} --
z data size

\end{description}\end{quote}

\end{fulllineitems}

\index{readData() (in module ClearMap.IO.TIF)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.IO:ClearMap.IO.TIF.readData}\pysiglinewithargsret{\bfcode{readData}}{\emph{filename}, \emph{x=\textless{}built-in function all\textgreater{}}, \emph{y=\textless{}built-in function all\textgreater{}}, \emph{z=\textless{}built-in function all\textgreater{}}, \emph{**args}}{}
Read data from a single tif image or stack
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{filename} (\emph{str}) --
file name as regular expression

\item {} 
\textbf{x,y,z} (\emph{tuple}) --
data range specifications

\end{itemize}

\item[{Returns}] \leavevmode
\emph{array} --
image data

\end{description}\end{quote}

\end{fulllineitems}

\index{writeData() (in module ClearMap.IO.TIF)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.IO:ClearMap.IO.TIF.writeData}\pysiglinewithargsret{\bfcode{writeData}}{\emph{filename}, \emph{data}}{}
Write image data to tif file
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{filename} (\emph{str}) --
file name

\item {} 
\textbf{data} (\emph{array}) --
image data

\end{itemize}

\item[{Returns}] \leavevmode
\emph{str} --
tif file name

\end{description}\end{quote}

\end{fulllineitems}

\index{copyData() (in module ClearMap.IO.TIF)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.IO:ClearMap.IO.TIF.copyData}\pysiglinewithargsret{\bfcode{copyData}}{\emph{source}, \emph{sink}}{}
Copy a data file from source to sink
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{source} (\emph{str}) --
file name pattern of source

\item {} 
\textbf{sink} (\emph{str}) --
file name pattern of sink

\end{itemize}

\item[{Returns}] \leavevmode
\emph{str} --
file name of the copy

\end{description}\end{quote}

\end{fulllineitems}

\index{test() (in module ClearMap.IO.TIF)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.IO:ClearMap.IO.TIF.test}\pysiglinewithargsret{\bfcode{test}}{}{}
Test TIF module

\end{fulllineitems}



\paragraph{ClearMap.IO.VTK module}
\label{api/ClearMap.IO:module-ClearMap.IO.VTK}\label{api/ClearMap.IO:clearmap-io-vtk-module}\index{ClearMap.IO.VTK (module)}
Interface to write points to VTK files
\paragraph{Notes}
\begin{itemize}
\item {} 
points are assumed to be in {[}x,y,z{]} coordinates as standard in ClearMap

\item {} 
reading of points not supported at the moment!

\end{itemize}

Author
\begin{quote}

Christoph Kirst, The Rockefeller University, New York City, 2015

Modified from matlab code by Kannan Umadevi Venkataraju
\end{quote}
\index{writePoints() (in module ClearMap.IO.VTK)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.IO:ClearMap.IO.VTK.writePoints}\pysiglinewithargsret{\bfcode{writePoints}}{\emph{filename}, \emph{points}, \emph{labelImage=None}}{}
Write point data to vtk file
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{filename} (\emph{str}) --
file name

\item {} 
\textbf{points} (\emph{array}) --
point data

\item {} 
\textbf{labelImage} (\emph{str, array or None}) --
optional label image to determine point label

\end{itemize}

\item[{Returns}] \leavevmode
\emph{str} --
file name

\end{description}\end{quote}

\end{fulllineitems}

\index{readPoints() (in module ClearMap.IO.VTK)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.IO:ClearMap.IO.VTK.readPoints}\pysiglinewithargsret{\bfcode{readPoints}}{\emph{filename}, \emph{**args}}{}
Read points form vtk file
\paragraph{Notes}
\begin{itemize}
\item {} 
Not implmented yet !

\end{itemize}

\end{fulllineitems}



\subsubsection{ClearMap.Alignment package}
\label{api/ClearMap.Alignment::doc}\label{api/ClearMap.Alignment:clearmap-alignment-package}\phantomsection\label{api/ClearMap.Alignment:module-ClearMap.Alignment}\index{ClearMap.Alignment (module)}
This sub-package provides an interface to alignment tools in order to
register cleared samples to atlases or reference samples.

Supported functionality:
\begin{itemize}
\item {} 
resampling and reorientation of large volumetric images in the
{\hyperref[api/ClearMap.Alignment:module-ClearMap.Alignment.Resampling]{\emph{\code{Resampling}}}} module.

\item {} 
registering volumetric data onto references via
\href{http://elastix.isi.uu.nl/}{Elastix} in the
{\hyperref[api/ClearMap.Alignment:module-ClearMap.Alignment.Elastix]{\emph{\code{Elastix}}}} module.

\end{itemize}

Main routines for resampling are:
{\hyperref[api/ClearMap.Alignment:ClearMap.Alignment.Resampling.resampleData]{\emph{\code{resampleData()}}}}
and {\hyperref[api/ClearMap.Alignment:ClearMap.Alignment.Resampling.resamplePoints]{\emph{\code{resamplePoints()}}}}.

Main routines for elastix registration are:
{\hyperref[api/ClearMap.Alignment:ClearMap.Alignment.Elastix.alignData]{\emph{\code{alignData()}}}},
{\hyperref[api/ClearMap.Alignment:ClearMap.Alignment.Elastix.transformData]{\emph{\code{transformData()}}}} and
{\hyperref[api/ClearMap.Alignment:ClearMap.Alignment.Elastix.transformPoints]{\emph{\code{transformPoints()}}}}.


\paragraph{ClearMap.Alignment.Elastix module}
\label{api/ClearMap.Alignment:clearmap-alignment-elastix-module}\label{api/ClearMap.Alignment:module-ClearMap.Alignment.Elastix}\index{ClearMap.Alignment.Elastix (module)}
Interface to Elastix for alignment of volumetric data

The elastix documentation can be found \href{http://elastix.isi.uu.nl/}{here}.

In essence, a transformation \(T(x)\) is sought so that for a fixed image
\(F(x)\) and a moving image \(M(x)\):
\begin{gather}
\begin{split}F(x) = M(T(x))\end{split}\notag
\end{gather}
Once the map \(T\) is estimated via elastix, transformix maps an image
\(I(x)\) from the moving image frame to the fixed image frame, i.e.:
\begin{gather}
\begin{split}I(x) \rightarrow I(T(x))\end{split}\notag
\end{gather}
To register an image onto a reference image, the fixed image is typically
choosed to be the image to be registered, while the moving image is the
reference image. In this way an object identified in the data at position x
is mapped via transformix as:
\begin{gather}
\begin{split}x \rightarrow T(x)\end{split}\notag
\end{gather}

\subparagraph{Summary}
\label{api/ClearMap.Alignment:summary}\begin{itemize}
\item {} 
elastix finds a transformation \(T: \mathrm{fixed image} \rightarrow \mathrm{moving image}\)

\item {} 
the fixed image is image to be registered

\item {} 
the moving image is typically the reference image

\item {} 
the result folder may contain an image (mhd file) that is \(T^{-1}(\mathrm{moving})\),
i.e. has the size of the fixed image

\item {} 
transformix applied to data gives \(T^{-1}(\mathrm{data})\) !

\item {} 
transformix applied to points gives \(T(\mathrm{points})\) !

\item {} 
point arrays are assumed to be in (x,y,z) coordinates consistent with (x,y,z) array represenation of images in ClearMap

\end{itemize}

Main routines are: {\hyperref[api/ClearMap.Alignment:ClearMap.Alignment.Elastix.alignData]{\emph{\code{alignData()}}}}, {\hyperref[api/ClearMap.Alignment:ClearMap.Alignment.Elastix.transformData]{\emph{\code{transformData()}}}} and {\hyperref[api/ClearMap.Alignment:ClearMap.Alignment.Elastix.transformPoints]{\emph{\code{transformPoints()}}}}.


\strong{See also:}


\href{http://elastix.isi.uu.nl/}{Elastix documentation}
{\hyperref[api/ClearMap.Alignment:module-ClearMap.Alignment.Resampling]{\emph{\code{Resampling}}}}


\index{ElastixBinary (in module ClearMap.Alignment.Elastix)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.Alignment:ClearMap.Alignment.Elastix.ElastixBinary}\pysigline{\bfcode{ElastixBinary}\strong{ = `/home/ckirst/programs/elastix/bin/elastix'}}
str: the elastix executable
\paragraph{Notes}
\begin{itemize}
\item {} 
setup in {\hyperref[api/ClearMap.Alignment:ClearMap.Alignment.Elastix.initializeElastix]{\emph{\code{initializeElastix()}}}}

\end{itemize}

\end{fulllineitems}

\index{ElastixLib (in module ClearMap.Alignment.Elastix)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.Alignment:ClearMap.Alignment.Elastix.ElastixLib}\pysigline{\bfcode{ElastixLib}\strong{ = `/home/ckirst/programs/elastix/lib'}}
str: path to the elastix library
\paragraph{Notes}
\begin{itemize}
\item {} 
setup in {\hyperref[api/ClearMap.Alignment:ClearMap.Alignment.Elastix.initializeElastix]{\emph{\code{initializeElastix()}}}}

\end{itemize}

\end{fulllineitems}

\index{TransformixBinary (in module ClearMap.Alignment.Elastix)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.Alignment:ClearMap.Alignment.Elastix.TransformixBinary}\pysigline{\bfcode{TransformixBinary}\strong{ = `/home/ckirst/programs/elastix/bin/transformix'}}
str: the transformix executable
\paragraph{Notes}
\begin{itemize}
\item {} 
setup in {\hyperref[api/ClearMap.Alignment:ClearMap.Alignment.Elastix.initializeElastix]{\emph{\code{initializeElastix()}}}}

\end{itemize}

\end{fulllineitems}

\index{Initialized (in module ClearMap.Alignment.Elastix)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.Alignment:ClearMap.Alignment.Elastix.Initialized}\pysigline{\bfcode{Initialized}\strong{ = True}}
bool: True if the elastixs binarys and paths are setup
\paragraph{Notes}
\begin{itemize}
\item {} 
setup in {\hyperref[api/ClearMap.Alignment:ClearMap.Alignment.Elastix.initializeElastix]{\emph{\code{initializeElastix()}}}}

\end{itemize}

\end{fulllineitems}

\index{printSettings() (in module ClearMap.Alignment.Elastix)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.Alignment:ClearMap.Alignment.Elastix.printSettings}\pysiglinewithargsret{\bfcode{printSettings}}{}{}
Prints the current elastix configuration


\strong{See also:}


{\hyperref[api/ClearMap.Alignment:ClearMap.Alignment.Elastix.ElastixBinary]{\emph{\code{ElastixBinary}}}}, {\hyperref[api/ClearMap.Alignment:ClearMap.Alignment.Elastix.ElastixLib]{\emph{\code{ElastixLib}}}}, {\hyperref[api/ClearMap.Alignment:ClearMap.Alignment.Elastix.TransformixBinary]{\emph{\code{TransformixBinary}}}}, {\hyperref[api/ClearMap.Alignment:ClearMap.Alignment.Elastix.Initialized]{\emph{\code{Initialized}}}}



\end{fulllineitems}

\index{setElastixLibraryPath() (in module ClearMap.Alignment.Elastix)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.Alignment:ClearMap.Alignment.Elastix.setElastixLibraryPath}\pysiglinewithargsret{\bfcode{setElastixLibraryPath}}{\emph{path=None}}{}
Add elastix library path to the LD\_LIBRARY\_PATH variable in linux
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{path} (\emph{str or None}) --
path to elastix root directory if None {\hyperref[api/ClearMap.Settings:ClearMap.Settings.ElastixPath]{\emph{\code{ClearMap.Settings.ElastixPath}}}} is used.

\end{description}\end{quote}

\end{fulllineitems}

\index{initializeElastix() (in module ClearMap.Alignment.Elastix)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.Alignment:ClearMap.Alignment.Elastix.initializeElastix}\pysiglinewithargsret{\bfcode{initializeElastix}}{\emph{path=None}}{}
Initialize all paths and binaries of elastix
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{path} (\emph{str or None}) --
path to elastix root directory, if None

\item {} 
\textbf{:const:{}`ClearMap.Settings.ElastixPath{}` is used.}

\end{itemize}

\end{description}\end{quote}


\strong{See also:}


{\hyperref[api/ClearMap.Alignment:ClearMap.Alignment.Elastix.ElastixBinary]{\emph{\code{ElastixBinary}}}}, {\hyperref[api/ClearMap.Alignment:ClearMap.Alignment.Elastix.ElastixLib]{\emph{\code{ElastixLib}}}}, {\hyperref[api/ClearMap.Alignment:ClearMap.Alignment.Elastix.TransformixBinary]{\emph{\code{TransformixBinary}}}},
{\hyperref[api/ClearMap.Alignment:ClearMap.Alignment.Elastix.Initialized]{\emph{\code{Initialized}}}}, {\hyperref[api/ClearMap.Alignment:ClearMap.Alignment.Elastix.setElastixLibraryPath]{\emph{\code{setElastixLibraryPath()}}}}



\end{fulllineitems}

\index{checkElastixInitialized() (in module ClearMap.Alignment.Elastix)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.Alignment:ClearMap.Alignment.Elastix.checkElastixInitialized}\pysiglinewithargsret{\bfcode{checkElastixInitialized}}{}{}
Checks if elastix is initialized
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\emph{bool} --
True if elastix paths are set.

\end{description}\end{quote}

\end{fulllineitems}

\index{getTransformParameterFile() (in module ClearMap.Alignment.Elastix)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.Alignment:ClearMap.Alignment.Elastix.getTransformParameterFile}\pysiglinewithargsret{\bfcode{getTransformParameterFile}}{\emph{resultdir}}{}
Finds and returns the transformation parameter file generated by elastix
\paragraph{Notes}

In case of multiple transformation parameter files the top level file is returned
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{resultdir} (\emph{str}) --
path to directory of elastix results

\item[{Returns}] \leavevmode
\emph{str} --
file name of the first transformation parameter file

\end{description}\end{quote}

\end{fulllineitems}

\index{setPathTransformParameterFiles() (in module ClearMap.Alignment.Elastix)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.Alignment:ClearMap.Alignment.Elastix.setPathTransformParameterFiles}\pysiglinewithargsret{\bfcode{setPathTransformParameterFiles}}{\emph{resultdir}}{}
Replaces relative with abolsute path in the parameter files in the result directory
\paragraph{Notes}

When elastix is not run in the directory of the transformation files
the aboslute path needs to be given in each transformation file
to point to the subsequent transformation files. This is done via this
routine
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{resultdir} (\emph{str}) --
path to directory of elastix results

\end{description}\end{quote}

\end{fulllineitems}

\index{parseElastixOutputPoints() (in module ClearMap.Alignment.Elastix)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.Alignment:ClearMap.Alignment.Elastix.parseElastixOutputPoints}\pysiglinewithargsret{\bfcode{parseElastixOutputPoints}}{\emph{filename}, \emph{indices=True}}{}
Parses the output points from the output file of transformix
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{filename} (\emph{str}) --
file name of the transformix output file

\item {} 
\textbf{indices} (\emph{bool}) --
if True return pixel indices otherwise float coordinates

\end{itemize}

\item[{Returns}] \leavevmode
\textbf{points} (\emph{array}) --
the transformed coordinates

\end{description}\end{quote}

\end{fulllineitems}

\index{getTransformFileSizeAndSpacing() (in module ClearMap.Alignment.Elastix)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.Alignment:ClearMap.Alignment.Elastix.getTransformFileSizeAndSpacing}\pysiglinewithargsret{\bfcode{getTransformFileSizeAndSpacing}}{\emph{transformfile}}{}
Parse the image size and spacing from a transformation parameter file
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{transformfile} (\emph{str}) --
File name of the transformix parameter file.

\item[{Returns}] \leavevmode
\emph{(float, float)} --
the image size and spacing

\end{description}\end{quote}

\end{fulllineitems}

\index{getResultDataFile() (in module ClearMap.Alignment.Elastix)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.Alignment:ClearMap.Alignment.Elastix.getResultDataFile}\pysiglinewithargsret{\bfcode{getResultDataFile}}{\emph{resultdir}}{}
Returns the mhd result file in a result directory
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{resultdir} (\emph{str}) --
Path to elastix result directory.

\item[{Returns}] \leavevmode
\emph{str} --
The mhd file in the result directory.

\end{description}\end{quote}

\end{fulllineitems}

\index{setTransformFileSizeAndSpacing() (in module ClearMap.Alignment.Elastix)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.Alignment:ClearMap.Alignment.Elastix.setTransformFileSizeAndSpacing}\pysiglinewithargsret{\bfcode{setTransformFileSizeAndSpacing}}{\emph{transformfile}, \emph{size}, \emph{spacing}}{}
Replaces size and scale in the transformation parameter file
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{transformfile} (\emph{str}) --
transformation parameter file

\item {} 
\textbf{size} (\emph{tuple}) --
the new image size

\item {} 
\textbf{spacing} (\emph{tuplr}) --
the new image spacing

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{rescaleSizeAndSpacing() (in module ClearMap.Alignment.Elastix)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.Alignment:ClearMap.Alignment.Elastix.rescaleSizeAndSpacing}\pysiglinewithargsret{\bfcode{rescaleSizeAndSpacing}}{\emph{size}, \emph{spacing}, \emph{scale}}{}
Rescales the size and spacing
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{size} (\emph{tuple}) --
image size

\item {} 
\textbf{spacing} (\emph{tuple}) --
image spacing

\item {} 
\textbf{scale} (\emph{tuple}) --
the scale factor

\end{itemize}

\item[{Returns}] \leavevmode
\emph{(tuple, tuple)} --
new size and spacing

\end{description}\end{quote}

\end{fulllineitems}

\index{alignData() (in module ClearMap.Alignment.Elastix)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.Alignment:ClearMap.Alignment.Elastix.alignData}\pysiglinewithargsret{\bfcode{alignData}}{\emph{fixedImage}, \emph{movingImage}, \emph{affineParameterFile}, \emph{bSplineParameterFile=None}, \emph{resultDirectory=None}}{}
Align images using elastix, estimates a transformation \(T:\) fixed image \(\rightarrow\) moving image.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{fixedImage} (\emph{str}) --
image source of the fixed image (typically the reference image)

\item {} 
\textbf{movingImage} (\emph{str}) --
image source of the moving image (typically the image to be registered)

\item {} 
\textbf{affineParameterFile} (\emph{str or None}) --
elastix parameter file for the primary affine transformation

\item {} 
\textbf{bSplineParameterFile} (\emph{str or None}) --
elastix parameter file for the secondary non-linear transformation

\item {} 
\textbf{resultDirectory} (\emph{str or None}) --
elastic result directory

\end{itemize}

\item[{Returns}] \leavevmode
\emph{str} --
path to elastix result directory

\end{description}\end{quote}

\end{fulllineitems}

\index{transformData() (in module ClearMap.Alignment.Elastix)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.Alignment:ClearMap.Alignment.Elastix.transformData}\pysiglinewithargsret{\bfcode{transformData}}{\emph{source}, \emph{sink={[}{]}}, \emph{transformParameterFile=None}, \emph{transformDirectory=None}, \emph{resultDirectory=None}}{}
Transform a raw data set to reference using the elastix alignment results

If the map determined by elastix is
\(T \mathrm{fixed} \rightarrow \mathrm{moving}\),
transformix on data works as :math:{\color{red}\bfseries{}{}`}T\textasciicircum{}\{-1\}(mathrm\{data\})
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{source} (\emph{str or array}) --
image source to be transformed

\item {} 
\textbf{sink} (\emph{str, {[}{]} or None}) --
image sink to save transformed image to. if {[}{]} return the default name of the data file generated by transformix.

\item {} 
\textbf{transformParameterFile} (\emph{str or None}) --
parameter file for the primary transformation, if None, the file is determined from the transformDirectory.

\item {} 
\textbf{transformDirectory} (\emph{str or None}) --
result directory of elastix alignment, if None the transformParameterFile has to be given.

\item {} 
\textbf{resultDirectory} (\emph{str or None}) --
the directorty for the transformix results

\end{itemize}

\item[{Returns}] \leavevmode
\emph{array or str} --
array or file name of the transformed data

\end{description}\end{quote}

\end{fulllineitems}

\index{deformationField() (in module ClearMap.Alignment.Elastix)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.Alignment:ClearMap.Alignment.Elastix.deformationField}\pysiglinewithargsret{\bfcode{deformationField}}{\emph{sink={[}{]}}, \emph{transformParameterFile=None}, \emph{transformDirectory=None}, \emph{resultDirectory=None}}{}
Create the deformation field T(x) - x

The map determined by elastix is
\(T \mathrm{fixed} \rightarrow \mathrm{moving}\)
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{sink} (\emph{str, {[}{]} or None}) --
image sink to save the transformation field; if {[}{]} return the default name of the data file generated by transformix.

\item {} 
\textbf{transformParameterFile} (\emph{str or None}) --
parameter file for the primary transformation, if None, the file is determined from the transformDirectory.

\item {} 
\textbf{transformDirectory} (\emph{str or None}) --
result directory of elastix alignment, if None the transformParameterFile has to be given.

\item {} 
\textbf{resultDirectory} (\emph{str or None}) --
the directorty for the transformix results

\end{itemize}

\item[{Returns}] \leavevmode
\emph{array or str} --
array or file name of the transformed data

\end{description}\end{quote}

\end{fulllineitems}

\index{deformationDistance() (in module ClearMap.Alignment.Elastix)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.Alignment:ClearMap.Alignment.Elastix.deformationDistance}\pysiglinewithargsret{\bfcode{deformationDistance}}{\emph{deformationField}, \emph{sink=None}, \emph{scale=None}}{}
Compute the distance field from a deformation vector field
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{deformationField} (\emph{str or array}) --
source of the deformation field determined by {\hyperref[api/ClearMap.Alignment:ClearMap.Alignment.Elastix.deformationField]{\emph{\code{deformationField()}}}}

\item {} 
\textbf{sink} (\emph{str or None}) --
image sink to save the deformation field to

\item {} 
\textbf{scale} (\emph{tuple or None}) --
scale factor for each dimension, if None = (1,1,1)

\end{itemize}

\item[{Returns}] \leavevmode
\emph{array or str} --
array or file name of the transformed data

\end{description}\end{quote}

\end{fulllineitems}

\index{writePoints() (in module ClearMap.Alignment.Elastix)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.Alignment:ClearMap.Alignment.Elastix.writePoints}\pysiglinewithargsret{\bfcode{writePoints}}{\emph{filename}, \emph{points}, \emph{indices=True}}{}
Write points as elastix/transformix point file
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{filename} (\emph{str}) --
file name of the elastix point file.

\item {} 
\textbf{points} (\emph{array or str}) --
source of the points.

\item {} 
\textbf{indices} (\emph{bool}) --
write as pixel indices or physical coordiantes

\end{itemize}

\item[{Returns}] \leavevmode
\emph{str} --
file name of the elastix point file

\end{description}\end{quote}

\end{fulllineitems}

\index{transformPoints() (in module ClearMap.Alignment.Elastix)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.Alignment:ClearMap.Alignment.Elastix.transformPoints}\pysiglinewithargsret{\bfcode{transformPoints}}{\emph{source}, \emph{sink=None}, \emph{transformParameterFile=None}, \emph{transformDirectory=None}, \emph{indices=True}, \emph{resultDirectory=None}, \emph{tmpFile=None}}{}
Transform coordinates math:\emph{x} via elastix estimated transformation to \(T(x)\)

Note the transformation is from the fixed image coorindates to the moving image coordiantes.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{source} (\emph{str}) --
source of the points

\item {} 
\textbf{sink} (\emph{str or None}) --
sink for transformed points

\item {} 
\textbf{transformParameterFile} (\emph{str or None}) --
parameter file for the primary transformation, if None, the file is determined from the transformDirectory.

\item {} 
\textbf{transformDirectory} (\emph{str or None}) --
result directory of elastix alignment, if None the transformParameterFile has to be given.

\item {} 
\textbf{indices} (\emph{bool}) --
if True use points as pixel coordinates otherwise spatial coordinates.

\item {} 
\textbf{resultDirectory} (\emph{str or None}) --
elastic result directory

\item {} 
\textbf{tmpFile} (\emph{str or None}) --
file name for the elastix point file.

\end{itemize}

\item[{Returns}] \leavevmode
\emph{array or str} --
array or file name of transformed points

\end{description}\end{quote}

\end{fulllineitems}

\index{test() (in module ClearMap.Alignment.Elastix)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.Alignment:ClearMap.Alignment.Elastix.test}\pysiglinewithargsret{\bfcode{test}}{}{}
Test Elastix module

\end{fulllineitems}



\paragraph{ClearMap.Alignment.Resampling module}
\label{api/ClearMap.Alignment:clearmap-alignment-resampling-module}\label{api/ClearMap.Alignment:module-ClearMap.Alignment.Resampling}\index{ClearMap.Alignment.Resampling (module)}
The \emph{Resampling} module provides methods to resample and reorient volumetric
and point data.

Resampling the data is usually necessary as the first step to match the
resolution and orientation of the reference object.

Main routines for resampling are: {\hyperref[api/ClearMap.Alignment:ClearMap.Alignment.Resampling.resampleData]{\emph{\code{resampleData()}}}}
and {\hyperref[api/ClearMap.Alignment:ClearMap.Alignment.Resampling.resamplePoints]{\emph{\code{resamplePoints()}}}}.


\subparagraph{Image Representation and Size}
\label{api/ClearMap.Alignment:image-representation-and-size}\begin{description}
\item[{The module assumes that images in arrays are arranged as}] \leavevmode\begin{itemize}
\item {} 
{[}x,y{]} or

\item {} 
{[}x,y,z{]}

\end{itemize}

\end{description}

where x,y,z correspond to the x,y,z coordinates as displayed in e.g. ImageJ.
For example an image of size (512,512) stored in an array \code{img} will have:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{img}\PYG{o}{.}\PYG{n}{shape}
\PYG{g+go}{(512,512)}
\end{Verbatim}

Points are assumed to be given as x,y,z coordinates

Parameters such as \emph{resolution} or \emph{dataSize} are assumed to be given in (x,y)
or (x,y,z) format, e.g.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{dataSize} \PYG{o}{=} \PYG{p}{(}\PYG{l+m+mi}{512}\PYG{p}{,}\PYG{l+m+mi}{512}\PYG{p}{)}
\end{Verbatim}


\subparagraph{Orientation}
\label{api/ClearMap.Alignment:orientation}
The \emph{orientation} parameter is a tuple of d numbers from 1 to d that specifies
the permutation of the axes, a minus sign infront of a numbeer indicates
inversion of that axes. For exmaple

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{orientation}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}
\end{Verbatim}

indicates that x and y should be exchanged and the new y axes should be reversed.

Generally a re-orientation is composed of first a permutation of the axes and then
inverting the indicated axes.

A \emph{permutation} is an orientation without signs and with numbers from 0 to d-1.
\paragraph{Examples}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{os}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{ClearMap.IO} \PYG{k+kn}{as} \PYG{n+nn}{io}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{ClearMap.Settings} \PYG{k+kn}{import} \PYG{n}{ClearMapPath}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{ClearMap.Alignment.Resampling} \PYG{k+kn}{import} \PYG{n}{resampleData}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{filename} \PYG{o}{=} \PYG{n}{os}\PYG{o}{.}\PYG{n}{path}\PYG{o}{.}\PYG{n}{join}\PYG{p}{(}\PYG{n}{ClearMapPath}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Test/Data/OME/16\PYGZhy{}17\PYGZhy{}27\PYGZus{}0\PYGZus{}8X\PYGZhy{}s3\PYGZhy{}20HF\PYGZus{}UltraII\PYGZus{}C00\PYGZus{}xyz\PYGZhy{}Table Z}\PYG{l+s}{\PYGZbs{}}\PYG{l+s}{d\PYGZob{}4\PYGZcb{}.ome.tif}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print} \PYG{n}{io}\PYG{o}{.}\PYG{n}{dataSize}\PYG{p}{(}\PYG{n}{filename}\PYG{p}{)}
\PYG{g+go}{(2160, 2560, 21)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{data} \PYG{o}{=} \PYG{n}{resampleData}\PYG{p}{(}\PYG{n}{filename}\PYG{p}{,} \PYG{n}{sink} \PYG{o}{=} \PYG{n+nb+bp}{None}\PYG{p}{,} \PYG{n}{resolutionSource} \PYG{o}{=} \PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,} \PYG{n}{orientation} \PYG{o}{=} \PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{,} \PYG{n}{resolutionSink} \PYG{o}{=} \PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,}\PYG{l+m+mi}{10}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print} \PYG{n}{data}\PYG{o}{.}\PYG{n}{shape}
\PYG{g+go}{(216, 256, 10)}
\end{Verbatim}
\index{fixOrientation() (in module ClearMap.Alignment.Resampling)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.Alignment:ClearMap.Alignment.Resampling.fixOrientation}\pysiglinewithargsret{\bfcode{fixOrientation}}{\emph{orientation}}{}
Convert orientation to standard format number sequence
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{orientation} (\emph{tuple or str}) --
orientation specification

\item[{Returns}] \leavevmode
\emph{tuple} --
orientation sequence

\end{description}\end{quote}


\strong{See also:}


{\hyperref[api/ClearMap.Alignment:orientation]{\emph{Orientation}}}



\end{fulllineitems}

\index{inverseOrientation() (in module ClearMap.Alignment.Resampling)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.Alignment:ClearMap.Alignment.Resampling.inverseOrientation}\pysiglinewithargsret{\bfcode{inverseOrientation}}{\emph{orientation}}{}
Returns the inverse permuation of the permutation orientation taking axis inversions into account.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{orientation} (\emph{tuple or str}) --
orientation specification

\item[{Returns}] \leavevmode
\emph{tuple} --
orientation sequence

\end{description}\end{quote}


\strong{See also:}


{\hyperref[api/ClearMap.Alignment:orientation]{\emph{Orientation}}}



\end{fulllineitems}

\index{orientationToPermuation() (in module ClearMap.Alignment.Resampling)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.Alignment:ClearMap.Alignment.Resampling.orientationToPermuation}\pysiglinewithargsret{\bfcode{orientationToPermuation}}{\emph{orientation}}{}
Extracts the permuation from an orientation.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{orientation} (\emph{tuple or str}) --
orientation specification

\item[{Returns}] \leavevmode
\emph{tuple} --
premutation sequence

\end{description}\end{quote}


\strong{See also:}


{\hyperref[api/ClearMap.Alignment:orientation]{\emph{Orientation}}}



\end{fulllineitems}

\index{orientResolution() (in module ClearMap.Alignment.Resampling)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.Alignment:ClearMap.Alignment.Resampling.orientResolution}\pysiglinewithargsret{\bfcode{orientResolution}}{\emph{resolution}, \emph{orientation}}{}
Permutes a resolution tuple according to the given orientation.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{resolution} (\emph{tuple}) --
resolution specification

\item {} 
\textbf{orientation} (\emph{tuple or str}) --
orientation specification

\end{itemize}

\item[{Returns}] \leavevmode
\emph{tuple} --
oriented resolution sequence

\end{description}\end{quote}


\strong{See also:}


{\hyperref[api/ClearMap.Alignment:orientation]{\emph{Orientation}}}



\end{fulllineitems}

\index{orientResolutionInverse() (in module ClearMap.Alignment.Resampling)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.Alignment:ClearMap.Alignment.Resampling.orientResolutionInverse}\pysiglinewithargsret{\bfcode{orientResolutionInverse}}{\emph{resolution}, \emph{orientation}}{}
Permutes a resolution tuple according to the inverse of a given orientation.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{resolution} (\emph{tuple}) --
resolution specification

\item {} 
\textbf{orientation} (\emph{tuple or str}) --
orientation specification

\end{itemize}

\item[{Returns}] \leavevmode
\emph{tuple} --
oriented resolution sequence

\end{description}\end{quote}


\strong{See also:}


{\hyperref[api/ClearMap.Alignment:orientation]{\emph{Orientation}}}



\end{fulllineitems}

\index{orientDataSize() (in module ClearMap.Alignment.Resampling)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.Alignment:ClearMap.Alignment.Resampling.orientDataSize}\pysiglinewithargsret{\bfcode{orientDataSize}}{\emph{dataSize}, \emph{orientation}}{}
Permutes a data size tuple according to the given orientation.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{dataSize} (\emph{tuple}) --
resolution specification

\item {} 
\textbf{orientation} (\emph{tuple or str}) --
orientation specification

\end{itemize}

\item[{Returns}] \leavevmode
\emph{tuple} --
oriented dataSize sequence

\end{description}\end{quote}


\strong{See also:}


{\hyperref[api/ClearMap.Alignment:orientation]{\emph{Orientation}}}



\end{fulllineitems}

\index{orientDataSizeInverse() (in module ClearMap.Alignment.Resampling)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.Alignment:ClearMap.Alignment.Resampling.orientDataSizeInverse}\pysiglinewithargsret{\bfcode{orientDataSizeInverse}}{\emph{dataSize}, \emph{orientation}}{}
Permutes a dataSize tuple according to the inverse of a given orientation.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{dataSize} (\emph{tuple}) --
dataSize specification

\item {} 
\textbf{orientation} (\emph{tuple or str}) --
orientation specification

\end{itemize}

\item[{Returns}] \leavevmode
\emph{tuple} --
oriented dataSize sequence

\end{description}\end{quote}


\strong{See also:}


{\hyperref[api/ClearMap.Alignment:orientation]{\emph{Orientation}}}



\end{fulllineitems}

\index{resampleDataSize() (in module ClearMap.Alignment.Resampling)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.Alignment:ClearMap.Alignment.Resampling.resampleDataSize}\pysiglinewithargsret{\bfcode{resampleDataSize}}{\emph{dataSizeSource}, \emph{dataSizeSink=None}, \emph{resolutionSource=None}, \emph{resolutionSink=None}, \emph{orientation=None}}{}
Calculate scaling factors and data sizes for resampling.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{dataSizeSource} (\emph{tuple}) --
data size of the original image

\item {} 
\textbf{dataSizeSink} (\emph{tuple or None}) --
data size of the resmapled image

\item {} 
\textbf{resolutionSource} (\emph{tuple or None}) --
resolution of the source image

\item {} 
\textbf{resolutionSink} (\emph{tuple or None}) --
resolution of the sink image

\item {} 
\textbf{orientation} (\emph{tuple or str}) --
re-orientation specification

\end{itemize}

\item[{Returns}] \leavevmode
\emph{tuple} --
data size of the source
tuple: data size of the sink
tuple: resolution of source
tuple: resolution of sink

\end{description}\end{quote}


\strong{See also:}


{\hyperref[api/ClearMap.Alignment:orientation]{\emph{Orientation}}}



\end{fulllineitems}

\index{fixInterpolation() (in module ClearMap.Alignment.Resampling)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.Alignment:ClearMap.Alignment.Resampling.fixInterpolation}\pysiglinewithargsret{\bfcode{fixInterpolation}}{\emph{interpolation}}{}
Converts interpolation given as string to cv2 interpolation object
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{interpolation} (\emph{str or object}) --
interpolation string or cv2 object

\item[{Returns}] \leavevmode
\emph{object} --
cv2 interpolation type

\end{description}\end{quote}

\end{fulllineitems}

\index{resampleXY() (in module ClearMap.Alignment.Resampling)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.Alignment:ClearMap.Alignment.Resampling.resampleXY}\pysiglinewithargsret{\bfcode{resampleXY}}{\emph{source}, \emph{dataSizeSink}, \emph{sink=None}, \emph{interpolation='linear'}, \emph{out=\textless{}open file `\textless{}stdout\textgreater{}'}, \emph{mode `w'\textgreater{}}, \emph{verbose=True}}{}
Resample a 2d image slice

This routine is used for resampling a large stack in parallel in xy or xz direction.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{source} (\emph{str or array}) --
2d image source

\item {} 
\textbf{dataSizeSink} (\emph{tuple}) --
size of the resmapled image

\item {} 
\textbf{sink} (\emph{str or None}) --
location for the resmapled image

\item {} 
\textbf{interpolation} (\emph{str}) --
interpolation method to use: `linear' or None (nearest pixel)

\item {} 
\textbf{out} (\emph{stdout}) --
where to write progress information

\item {} 
\textbf{vebose} (\emph{bool}) --
write progress info if true

\end{itemize}

\item[{Returns}] \leavevmode
\emph{array or str} --
resampled data or file name

\end{description}\end{quote}

\end{fulllineitems}

\index{resampleData() (in module ClearMap.Alignment.Resampling)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.Alignment:ClearMap.Alignment.Resampling.resampleData}\pysiglinewithargsret{\bfcode{resampleData}}{\emph{source}, \emph{sink=None}, \emph{orientation=None}, \emph{dataSizeSink=None}, \emph{resolutionSource=(4.0625}, \emph{4.0625}, \emph{3)}, \emph{resolutionSink=(25}, \emph{25}, \emph{25)}, \emph{processingDirectory=None}, \emph{processes=1}, \emph{cleanup=True}, \emph{verbose=True}, \emph{interpolation='linear'}, \emph{**args}}{}
Resample data of source in resolution and orientation
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{source} (\emph{str or array}) --
image to be resampled

\item {} 
\textbf{sink} (\emph{str or None}) --
destination of resampled image

\item {} 
\textbf{orientation} (\emph{tuple}) --
orientation specified by permuation and change in sign of (1,2,3)

\item {} 
\textbf{dataSizeSink} (\emph{tuple or None}) --
target size of the resampled image

\item {} 
\textbf{resolutionSource} (\emph{tuple}) --
resolution of the source image (in length per pixel)

\item {} 
\textbf{resolutionSink} (\emph{tuple}) --
resolution of the resampled image (in length per pixel)

\item {} 
\textbf{processingDirectory} (\emph{str or None}) --
directory in which to perform resmapling in parallel, None a temporary directry will be created

\item {} 
\textbf{processes} (\emph{int}) --
number of processes to use for parallel resampling

\item {} 
\textbf{cleanup} (\emph{bool}) --
remove temporary files

\item {} 
\textbf{verbose} (\emph{bool}) --
display progress information

\item {} 
\textbf{interpolation} (\emph{str}) --
method to use for interpolating to the resmapled image

\end{itemize}

\item[{Returns}] \leavevmode
\emph{(array or str)} --
data or file name of resampled image

\end{description}\end{quote}
\paragraph{Notes}
\begin{itemize}
\item {} 
resolutions are assumed to be given for the axes of the intrinsic
orientation of the data and reference as when viewed by matplotlib or ImageJ

\item {} 
orientation: permuation of 1,2,3 with potential sign, indicating which
axes map onto the reference axes, a negative sign indicates reversal
of that particular axes

\item {} 
only a minimal set of information to detremine the resampling parameter
has to be given, e.g. dataSizeSource and dataSizeSink

\end{itemize}

\end{fulllineitems}

\index{resampleDataInverse() (in module ClearMap.Alignment.Resampling)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.Alignment:ClearMap.Alignment.Resampling.resampleDataInverse}\pysiglinewithargsret{\bfcode{resampleDataInverse}}{\emph{sink}, \emph{source=None}, \emph{dataSizeSource=None}, \emph{orientation=None}, \emph{resolutionSource=(4.0625}, \emph{4.0625}, \emph{3)}, \emph{resolutionSink=(25}, \emph{25}, \emph{25)}, \emph{processingDirectory=None}, \emph{processes=1}, \emph{cleanup=True}, \emph{verbose=True}, \emph{interpolation='linear'}, \emph{**args}}{}
Resample data inversely to {\hyperref[api/ClearMap.Alignment:ClearMap.Alignment.Resampling.resampleData]{\emph{\code{resampleData()}}}} routine
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{sink} (\emph{str or None}) --
image to be inversly resampled (=sink in {\hyperref[api/ClearMap.Alignment:ClearMap.Alignment.Resampling.resampleData]{\emph{\code{resampleData()}}}})

\item {} 
\textbf{source} (\emph{str or array}) --
destination for inversly resmapled image (=source in {\hyperref[api/ClearMap.Alignment:ClearMap.Alignment.Resampling.resampleData]{\emph{\code{resampleData()}}}})

\item {} 
\textbf{dataSizeSource} (\emph{tuple or None}) --
target size of the resampled image

\item {} 
\textbf{orientation} (\emph{tuple}) --
orientation specified by permuation and change in sign of (1,2,3)

\item {} 
\textbf{resolutionSource} (\emph{tuple}) --
resolution of the source image (in length per pixel)

\item {} 
\textbf{resolutionSink} (\emph{tuple}) --
resolution of the resampled image (in length per pixel)

\item {} 
\textbf{processingDirectory} (\emph{str or None}) --
directory in which to perform resmapling in parallel, None a temporary directry will be created

\item {} 
\textbf{processes} (\emph{int}) --
number of processes to use for parallel resampling

\item {} 
\textbf{cleanup} (\emph{bool}) --
remove temporary files

\item {} 
\textbf{verbose} (\emph{bool}) --
display progress information

\item {} 
\textbf{interpolation} (\emph{str}) --
method to use for interpolating to the resmapled image

\end{itemize}

\item[{Returns}] \leavevmode
\emph{(array or str)} --
data or file name of resampled image

\end{description}\end{quote}
\paragraph{Notes}
\begin{itemize}
\item {} 
resolutions are assumed to be given for the axes of the intrinsic
orientation of the data and reference as when viewed by matplotlib or ImageJ

\item {} 
orientation: permuation of 1,2,3 with potential sign, indicating which
axes map onto the reference axes, a negative sign indicates reversal
of that particular axes

\item {} 
only a minimal set of information to detremine the resampling parameter
has to be given, e.g. dataSizeSource and dataSizeSink

\end{itemize}

\end{fulllineitems}

\index{resamplePoints() (in module ClearMap.Alignment.Resampling)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.Alignment:ClearMap.Alignment.Resampling.resamplePoints}\pysiglinewithargsret{\bfcode{resamplePoints}}{\emph{pointSource}, \emph{pointSink=None}, \emph{dataSizeSource=None}, \emph{dataSizeSink=None}, \emph{orientation=None}, \emph{resolutionSource=(4.0625}, \emph{4.0625}, \emph{3)}, \emph{resolutionSink=(25}, \emph{25}, \emph{25)}, \emph{**args}}{}
Resample Points to map from original data to the coordinates of the resampled image

The resampling of points here corresponds to he resampling of an image in {\hyperref[api/ClearMap.Alignment:ClearMap.Alignment.Resampling.resampleData]{\emph{\code{resampleData()}}}}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{pointSource} (\emph{str or array}) --
image to be resampled

\item {} 
\textbf{pointSink} (\emph{str or None}) --
destination of resampled image

\item {} 
\textbf{orientation} (\emph{tuple}) --
orientation specified by permuation and change in sign of (1,2,3)

\item {} 
\textbf{dataSizeSource} (\emph{str, tuple or None}) --
size of the data source

\item {} 
\textbf{dataSizeSink} (\emph{str, tuple or None}) --
target size of the resampled image

\item {} 
\textbf{resolutionSource} (\emph{tuple}) --
resolution of the source image (in length per pixel)

\item {} 
\textbf{resolutionSink} (\emph{tuple}) --
resolution of the resampled image (in length per pixel)

\end{itemize}

\item[{Returns}] \leavevmode
\emph{(array or str)} --
data or file name of resampled points

\end{description}\end{quote}
\paragraph{Notes}
\begin{itemize}
\item {} 
resolutions are assumed to be given for the axes of the intrinsic
orientation of the data and reference as when viewed by matplotlib or ImageJ

\item {} 
orientation: permuation of 1,2,3 with potential sign, indicating which
axes map onto the reference axes, a negative sign indicates reversal
of that particular axes

\item {} 
only a minimal set of information to detremine the resampling parameter
has to be given, e.g. dataSizeSource and dataSizeSink

\end{itemize}

\end{fulllineitems}

\index{resamplePointsInverse() (in module ClearMap.Alignment.Resampling)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.Alignment:ClearMap.Alignment.Resampling.resamplePointsInverse}\pysiglinewithargsret{\bfcode{resamplePointsInverse}}{\emph{pointSource}, \emph{pointSink=None}, \emph{dataSizeSource=None}, \emph{dataSizeSink=None}, \emph{orientation=None}, \emph{resolutionSource=(4.0625}, \emph{4.0625}, \emph{3)}, \emph{resolutionSink=(25}, \emph{25}, \emph{25)}, \emph{**args}}{}
Resample points from the coordinates of the resampled image to the original data

The resampling of points here corresponds to he resampling of an image in {\hyperref[api/ClearMap.Alignment:ClearMap.Alignment.Resampling.resampleDataInverse]{\emph{\code{resampleDataInverse()}}}}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{pointSource} (\emph{str or array}) --
image to be resampled

\item {} 
\textbf{pointSink} (\emph{str or None}) --
destination of resampled image

\item {} 
\textbf{orientation} (\emph{tuple}) --
orientation specified by permuation and change in sign of (1,2,3)

\item {} 
\textbf{dataSizeSource} (\emph{str, tuple or None}) --
size of the data source

\item {} 
\textbf{dataSizeSink} (\emph{str, tuple or None}) --
target size of the resampled image

\item {} 
\textbf{resolutionSource} (\emph{tuple}) --
resolution of the source image (in length per pixel)

\item {} 
\textbf{resolutionSink} (\emph{tuple}) --
resolution of the resampled image (in length per pixel)

\end{itemize}

\item[{Returns}] \leavevmode
\emph{(array or str)} --
data or file name of inversely resampled points

\end{description}\end{quote}
\paragraph{Notes}
\begin{itemize}
\item {} 
resolutions are assumed to be given for the axes of the intrinsic
orientation of the data and reference as when viewed by matplotlib or ImageJ

\item {} 
orientation: permuation of 1,2,3 with potential sign, indicating which
axes map onto the reference axes, a negative sign indicates reversal
of that particular axes

\item {} 
only a minimal set of information to detremine the resampling parameter
has to be given, e.g. dataSizeSource and dataSizeSink

\end{itemize}

\end{fulllineitems}

\index{sagittalToCoronalData() (in module ClearMap.Alignment.Resampling)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.Alignment:ClearMap.Alignment.Resampling.sagittalToCoronalData}\pysiglinewithargsret{\bfcode{sagittalToCoronalData}}{\emph{source}, \emph{sink=None}}{}
Change from saggital to coronal orientation
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{source} (\emph{str or array}) --
source data to be reoriented

\item {} 
\textbf{sink} (\emph{str or None}) --
destination for reoriented image

\end{itemize}

\item[{Returns}] \leavevmode
\emph{str or array} --
reoriented data

\end{description}\end{quote}

\end{fulllineitems}



\subsubsection{ClearMap.ImageProcessing package}
\label{api/ClearMap.ImageProcessing:clearmap-imageprocessing-package}\label{api/ClearMap.ImageProcessing::doc}\label{api/ClearMap.ImageProcessing:module-ClearMap.ImageProcessing}\index{ClearMap.ImageProcessing (module)}
This sub-package provides routines for volumetric image processing in parallel

This part of the \emph{ClearMap} toolbox is desinged in a modular way to allow for
fast and flexible extension and addition of specific image processing
algorithms.
\begin{description}
\item[{The toolbox part consists of two parts:}] \leavevmode\begin{itemize}
\item {} 
{\hyperref[api/ClearMap.ImageProcessing:volumetric-image-processing]{\emph{Volumetric Image Processing}}}

\item {} 
{\hyperref[api/ClearMap.ImageProcessing:parallel-image-processing]{\emph{Parallel Image Processing}}}

\end{itemize}

\end{description}


\paragraph{Volumetric Image Processing}
\label{api/ClearMap.ImageProcessing:volumetric-image-processing}
The image processing routines provided in the standard package are listed below

\begin{tabulary}{\linewidth}{|L|L|}
\hline
\textsf{\relax 
Module
} & \textsf{\relax 
Descrition
}\\
\hline
{\hyperref[api/ClearMap.ImageProcessing:module-ClearMap.ImageProcessing.BackgroundRemoval]{\emph{\code{BackgroundRemoval}}}}
 & 
Background estimation and removal via morphological opening
\\
\hline
{\hyperref[api/ClearMap.ImageProcessing:module-ClearMap.ImageProcessing.IlluminationCorrection]{\emph{\code{IlluminationCorrection}}}}
 & 
Correction of vignetting and other illumination errors
\\
\hline
{\hyperref[api/ClearMap.ImageProcessing:module-ClearMap.ImageProcessing.GreyReconstruction]{\emph{\code{GreyReconstruction}}}}
 & 
Reconstruction of images
\\
\hline
{\hyperref[api/ClearMap.ImageProcessing.Filter:module-ClearMap.ImageProcessing.Filter]{\emph{\code{Filter}}}}
 & 
Filtering of images via a large set of filter kernels
\\
\hline
{\hyperref[api/ClearMap.ImageProcessing:module-ClearMap.ImageProcessing.MaximaDetection]{\emph{\code{MaximaDetection}}}}
 & 
Detection of maxima and h-max transforms
\\
\hline
{\hyperref[api/ClearMap.ImageProcessing:module-ClearMap.ImageProcessing.SpotDetection]{\emph{\code{SpotDetection}}}}
 & 
Detection of local peaks / spots / nuclei
\\
\hline
{\hyperref[api/ClearMap.ImageProcessing:module-ClearMap.ImageProcessing.CellDetection]{\emph{\code{CellDetection}}}}
 & 
Detection of cells
\\
\hline
{\hyperref[api/ClearMap.ImageProcessing:module-ClearMap.ImageProcessing.CellSizeDetection]{\emph{\code{CellSizeDetection}}}}
 & 
Detection of cell shapes and volumes via e.g. watershed
\\
\hline
{\hyperref[api/ClearMap.ImageProcessing:module-ClearMap.ImageProcessing.IlastikClassification]{\emph{\code{IlastikClassification}}}}
 & 
Classification of voxels via interface to \href{http://ilastik.org/}{Ilastik}
\\
\hline\end{tabulary}


While some of these modules provide basic volumetric image processing
functionality some routines combine those functions to provide predefined
higher level cell detection, cell size and intensity measurements.

The higher level routines are optimized for iDISCO+ cleared mouse brain samples
stained for cfos expression. Other data sets might require a redesign of these
higher level functions.


\paragraph{Parallel Image Processing}
\label{api/ClearMap.ImageProcessing:parallel-image-processing}
For large volumetric image data sets from e.g. light sheet microscopy
parallel processing is essential to speed up calculations.

In this toolbox the image processing is parallized via splitting a volumetric
image stack into several sub-stacks, typically in z-direction. Because most of
the image processig steps are non-local sub-stacks are created with overlaps
and the results rejoined accordingly to minimize boundary effects.

Parallel processing is handled via the
{\hyperref[api/ClearMap.ImageProcessing:module-ClearMap.ImageProcessing.StackProcessing]{\emph{\code{StackProcessing}}}} module.


\paragraph{External Packages}
\label{api/ClearMap.ImageProcessing:external-packages}
The {\hyperref[api/ClearMap.ImageProcessing:module-ClearMap.ImageProcessing]{\emph{\code{ImageProcessing}}}} module makes use of external image
processing packages including:
\begin{itemize}
\item {} 
\href{http://opencv.org/}{Open Cv2}

\item {} 
\href{http://www.scipy.org/}{Scipy}

\item {} 
\href{http://scikit-image.org/docs/dev/api/skimage.html}{Scikit-Image}

\item {} 
\href{http://ilastik.org/}{Ilastik}

\end{itemize}

Routines form these packages were freely choosen to optimize for speed and
memory consumption


\paragraph{ClearMap.ImageProcessing.StackProcessing module}
\label{api/ClearMap.ImageProcessing:clearmap-imageprocessing-stackprocessing-module}\label{api/ClearMap.ImageProcessing:module-ClearMap.ImageProcessing.StackProcessing}\index{ClearMap.ImageProcessing.StackProcessing (module)}
Process a image stack in parallel or sequentially

In this toolbox image processing is parallized via splitting a volumetric
image stack into several sub-stacks, typically in z-direction. As most of
the image processig steps are non-local sub-stacks are created with overlaps
and the results rejoined accordingly to minimize boundary effects.

Parallel processing is handled via the
{\hyperref[api/ClearMap.ImageProcessing:module-ClearMap.ImageProcessing.StackProcessing]{\emph{\code{StackProcessing}}}} module.

The parallel processing module creates a dictionary with information on
the sub-stack as follows:
\phantomsection\label{api/ClearMap.ImageProcessing:substack}
\begin{tabulary}{\linewidth}{|L|L|}
\hline
\textsf{\relax 
Key
} & \textsf{\relax 
Description
}\\
\hline
\code{stackId}
 & 
id of the sub-stack
\\
\hline
\code{nStacks}
 & 
total number of sub-stacks
\\
\hline
\code{source}
 & 
source file/folder/pattern of the stack
\\
\hline
\code{x}, \code{y}, \code{z}
 & 
the range of the sub-stack withing the full image
\\
\hline
\code{zCenters}
 & 
tuple of the centers of the overlaps
\\
\hline
\code{zCenterIndices}
 & 
tuple of the original indices of the centers of
the overlaps
\\
\hline
\code{zSubStackCenterIndices}
 & 
tuple of the indices of the sub-stack that
correspond to the overlap centers
\\
\hline\end{tabulary}


For exmaple the {\hyperref[api/ClearMap.ImageProcessing:ClearMap.ImageProcessing.StackProcessing.writeSubStack]{\emph{\code{writeSubStack()}}}} routine makes uses of this information
to write out only the sub-parts of the image that is will contribute to the
final total image.
\index{printSubStackInfo() (in module ClearMap.ImageProcessing.StackProcessing)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.ImageProcessing:ClearMap.ImageProcessing.StackProcessing.printSubStackInfo}\pysiglinewithargsret{\bfcode{printSubStackInfo}}{\emph{subStack}, \emph{out=\textless{}open file `\textless{}stdout\textgreater{}'}, \emph{mode `w'\textgreater{}}}{}
Print information about the sub-stack
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{subStack} (\emph{dict}) --
the sub-stack info

\item {} 
\textbf{out} (\emph{object}) --
the object to write the information to

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{writeSubStack() (in module ClearMap.ImageProcessing.StackProcessing)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.ImageProcessing:ClearMap.ImageProcessing.StackProcessing.writeSubStack}\pysiglinewithargsret{\bfcode{writeSubStack}}{\emph{filename}, \emph{img}, \emph{subStack=None}}{}
Write the non-redundant part of a sub-stack to disk

The routine is used to write out images when porcessed in parallel.
It assumes that the filename is a patterned file name.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{filename} (\emph{str or None}) --
file name pattern as described in
\code{FileList}, if None return as array

\item {} 
\textbf{img} (\emph{array}) --
image data of sub-stack

\item {} 
\textbf{subStack} (\emph{dict or None}) --
sub-stack information, if None write entire image
see \DUspan{xref,std,std-ref}{SubStack}

\end{itemize}

\item[{Returns}] \leavevmode
\emph{str or array} --
the file name pattern or image

\end{description}\end{quote}

\end{fulllineitems}

\index{joinPoints() (in module ClearMap.ImageProcessing.StackProcessing)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.ImageProcessing:ClearMap.ImageProcessing.StackProcessing.joinPoints}\pysiglinewithargsret{\bfcode{joinPoints}}{\emph{results}, \emph{subStacks=None}, \emph{shiftPoints=True}, \emph{**args}}{}
Joins a list of points obtained from processing a stack in chunks
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{results} (\emph{list}) --
list of point results from the individual sub-processes

\item {} 
\textbf{subStacks} (\emph{list or None}) --
list of all sub-stack information, see \DUspan{xref,std,std-ref}{SubStack}

\item {} 
\textbf{shiftPoints} (\emph{bool}) --
if True shift points to refer to origin of the image stack considered
when range specification is given. If False, absolute
position in entire image stack.

\end{itemize}

\item[{Returns}] \leavevmode
\emph{tuple} --
joined points, joined intensities

\end{description}\end{quote}

\end{fulllineitems}

\index{calculateChunkSize() (in module ClearMap.ImageProcessing.StackProcessing)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.ImageProcessing:ClearMap.ImageProcessing.StackProcessing.calculateChunkSize}\pysiglinewithargsret{\bfcode{calculateChunkSize}}{\emph{size}, \emph{processes=2}, \emph{chunkSizeMax=100}, \emph{chunkSizeMin=30}, \emph{chunkOverlap=15}, \emph{chunkOptimization=True}, \emph{chunkOptimizationSize=\textless{}built-in function all\textgreater{}}, \emph{verbose=True}}{}
Calculates the chunksize and other info for parallel processing

The sub stack information is described in \DUspan{xref,std,std-ref}{SubStack}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{processes} (\emph{int}) --
number of parallel processes

\item {} 
\textbf{chunkSizeMax} (\emph{int}) --
maximal size of a sub-stack

\item {} 
\textbf{chunkSizeMin} (\emph{int}) --
minial size of a sub-stack

\item {} 
\textbf{chunkOverlap} (\emph{int}) --
minimal sub-stack overlap

\item {} 
\textbf{chunkOptimization} (\emph{bool}) --
optimize chunck sizes to best fit number of processes

\item {} 
\textbf{chunkOptimizationSize} (\emph{bool or all}) --
if True only decrease the chunk size when optimizing

\item {} 
\textbf{verbose} (\emph{bool}) --
print information on sub-stack generation

\end{itemize}

\item[{Returns}] \leavevmode
\emph{tuple} --
number of chunks, z-ranges of each chunk, z-centers in overlap regions

\end{description}\end{quote}

\end{fulllineitems}

\index{calculateSubStacks() (in module ClearMap.ImageProcessing.StackProcessing)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.ImageProcessing:ClearMap.ImageProcessing.StackProcessing.calculateSubStacks}\pysiglinewithargsret{\bfcode{calculateSubStacks}}{\emph{source}, \emph{z=\textless{}built-in function all\textgreater{}}, \emph{x=\textless{}built-in function all\textgreater{}}, \emph{y=\textless{}built-in function all\textgreater{}}, \emph{**args}}{}
Calculates the chunksize and other info for parallel processing and returns a list of sub-stack objects

The sub-stack information is described in \DUspan{xref,std,std-ref}{SubStack}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{source} (\emph{str}) --
image source

\item {} 
\textbf{x,y,z} (\emph{tuple or all}) --
range specifications

\item {} 
\textbf{processes} (\emph{int}) --
number of parallel processes

\item {} 
\textbf{chunkSizeMax} (\emph{int}) --
maximal size of a sub-stack

\item {} 
\textbf{chunkSizeMin} (\emph{int}) --
minial size of a sub-stack

\item {} 
\textbf{chunkOverlap} (\emph{int}) --
minimal sub-stack overlap

\item {} 
\textbf{chunkOptimization} (\emph{bool}) --
optimize chunck sizes to best fit number of processes

\item {} 
\textbf{chunkOptimizationSize} (\emph{bool or all}) --
if True only decrease the chunk size when optimizing

\item {} 
\textbf{verbose} (\emph{bool}) --
print information on sub-stack generation

\end{itemize}

\item[{Returns}] \leavevmode
\emph{list} --
list of sub-stack objects

\end{description}\end{quote}

\end{fulllineitems}

\index{noProcessing() (in module ClearMap.ImageProcessing.StackProcessing)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.ImageProcessing:ClearMap.ImageProcessing.StackProcessing.noProcessing}\pysiglinewithargsret{\bfcode{noProcessing}}{\emph{img}, \emph{**parameter}}{}
Perform no image processing at all and return original image

Used as the default functon in {\hyperref[api/ClearMap.ImageProcessing:ClearMap.ImageProcessing.StackProcessing.parallelProcessStack]{\emph{\code{parallelProcessStack()}}}} and
{\hyperref[api/ClearMap.ImageProcessing:ClearMap.ImageProcessing.StackProcessing.sequentiallyProcessStack]{\emph{\code{sequentiallyProcessStack()}}}}.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{img} (\emph{array}) --
imag

\item[{Returns}] \leavevmode
\emph{(array)} --
the original image

\end{description}\end{quote}

\end{fulllineitems}

\index{parallelProcessStack() (in module ClearMap.ImageProcessing.StackProcessing)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.ImageProcessing:ClearMap.ImageProcessing.StackProcessing.parallelProcessStack}\pysiglinewithargsret{\bfcode{parallelProcessStack}}{\emph{source}, \emph{x=\textless{}built-in function all\textgreater{}}, \emph{y=\textless{}built-in function all\textgreater{}}, \emph{z=\textless{}built-in function all\textgreater{}}, \emph{sink=None}, \emph{processes=2}, \emph{chunkSizeMax=100}, \emph{chunkSizeMin=30}, \emph{chunkOverlap=15}, \emph{chunkOptimization=True}, \emph{chunkOptimizationSize=\textless{}built-in function all\textgreater{}}, \emph{function=\textless{}function noProcessing\textgreater{}}, \emph{join=\textless{}function joinPoints\textgreater{}}, \emph{verbose=False}, \emph{**parameter}}{}
Parallel process a image stack

Main routine that distributes image processing on paralllel processes.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{source} (\emph{str}) --
image source

\item {} 
\textbf{x,y,z} (\emph{tuple or all}) --
range specifications

\item {} 
\textbf{sink} (\emph{str or None}) --
destination for the result

\item {} 
\textbf{processes} (\emph{int}) --
number of parallel processes

\item {} 
\textbf{chunkSizeMax} (\emph{int}) --
maximal size of a sub-stack

\item {} 
\textbf{chunkSizeMin} (\emph{int}) --
minial size of a sub-stack

\item {} 
\textbf{chunkOverlap} (\emph{int}) --
minimal sub-stack overlap

\item {} 
\textbf{chunkOptimization} (\emph{bool}) --
optimize chunck sizes to best fit number of processes

\item {} 
\textbf{chunkOptimizationSize} (\emph{bool or all}) --
if True only decrease the chunk size when optimizing

\item {} 
\textbf{function} (\emph{function}) --
the main image processing script

\item {} 
\textbf{join} (\emph{function}) --
the fuction to join the results from the image processing script

\item {} 
\textbf{verbose} (\emph{bool}) --
print information on sub-stack generation

\end{itemize}

\item[{Returns}] \leavevmode
\emph{str or array} --
results of the image processing

\end{description}\end{quote}

\end{fulllineitems}

\index{sequentiallyProcessStack() (in module ClearMap.ImageProcessing.StackProcessing)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.ImageProcessing:ClearMap.ImageProcessing.StackProcessing.sequentiallyProcessStack}\pysiglinewithargsret{\bfcode{sequentiallyProcessStack}}{\emph{source}, \emph{x=\textless{}built-in function all\textgreater{}}, \emph{y=\textless{}built-in function all\textgreater{}}, \emph{z=\textless{}built-in function all\textgreater{}}, \emph{sink=None}, \emph{chunkSizeMax=100}, \emph{chunkSizeMin=30}, \emph{chunkOverlap=15}, \emph{function=\textless{}function noProcessing\textgreater{}}, \emph{join=\textless{}function joinPoints\textgreater{}}, \emph{verbose=False}, \emph{**parameter}}{}
Sequential image processing on a stack

Main routine that sequentially processes a large image on sub-stacks.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{source} (\emph{str}) --
image source

\item {} 
\textbf{x,y,z} (\emph{tuple or all}) --
range specifications

\item {} 
\textbf{sink} (\emph{str or None}) --
destination for the result

\item {} 
\textbf{processes} (\emph{int}) --
number of parallel processes

\item {} 
\textbf{chunkSizeMax} (\emph{int}) --
maximal size of a sub-stack

\item {} 
\textbf{chunkSizeMin} (\emph{int}) --
minial size of a sub-stack

\item {} 
\textbf{chunkOverlap} (\emph{int}) --
minimal sub-stack overlap

\item {} 
\textbf{chunkOptimization} (\emph{bool}) --
optimize chunck sizes to best fit number of processes

\item {} 
\textbf{chunkOptimizationSize} (\emph{bool or all}) --
if True only decrease the chunk size when optimizing

\item {} 
\textbf{function} (\emph{function}) --
the main image processing script

\item {} 
\textbf{join} (\emph{function}) --
the fuction to join the results from the image processing script

\item {} 
\textbf{verbose} (\emph{bool}) --
print information on sub-stack generation

\end{itemize}

\item[{Returns}] \leavevmode
\emph{str or array} --
results of the image processing

\end{description}\end{quote}

\end{fulllineitems}



\paragraph{ClearMap.ImageProcessing.CellDetection module}
\label{api/ClearMap.ImageProcessing:module-ClearMap.ImageProcessing.CellDetection}\label{api/ClearMap.ImageProcessing:clearmap-imageprocessing-celldetection-module}\index{ClearMap.ImageProcessing.CellDetection (module)}
Cell Detection Module

This is the main routine to run the individual routines to detect cells om
volumetric image data.

ClearMap supports two predefined image processing pipelines which will extend
in the future:
\paragraph{Example}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{ClearMap.IO} \PYG{k+kn}{as} \PYG{n+nn}{io}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{ClearMap.Settings} \PYG{k+kn}{as} \PYG{n+nn}{settings}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{ClearMap.ImageProcessing.CellDetection} \PYG{k+kn}{import} \PYG{n}{detectCells}\PYG{p}{;}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{fn} \PYG{o}{=} \PYG{n}{os}\PYG{o}{.}\PYG{n}{path}\PYG{o}{.}\PYG{n}{join}\PYG{p}{(}\PYG{n}{settings}\PYG{o}{.}\PYG{n}{ClearMapPath}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Test/Data/Synthetic/test\PYGZus{}iDISCO\PYGZus{}}\PYG{l+s}{\PYGZbs{}}\PYG{l+s}{d\PYGZob{}3\PYGZcb{}.tif}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{parameter} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{filterDoGParameter}\PYG{l+s}{\PYGZdq{}} \PYG{p}{:} \PYG{p}{\PYGZob{}}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{size}\PYG{l+s}{\PYGZdq{}}\PYG{p}{:} \PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{\PYGZcb{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{findExtendedMaximaParameter}\PYG{l+s}{\PYGZdq{}} \PYG{p}{:} \PYG{p}{\PYGZob{}}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{threshold}\PYG{l+s}{\PYGZdq{}} \PYG{p}{:} \PYG{l+m+mi}{5}\PYG{p}{\PYGZcb{}}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{img} \PYG{o}{=} \PYG{n}{io}\PYG{o}{.}\PYG{n}{readData}\PYG{p}{(}\PYG{n}{fn}\PYG{p}{)}\PYG{p}{;}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{img} \PYG{o}{=} \PYG{n}{img}\PYG{o}{.}\PYG{n}{astype}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{int16}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{;} \PYG{c}{\PYGZsh{} converting data to smaller integer types can be more memory efficient!}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{res} \PYG{o}{=} \PYG{n}{detectCells}\PYG{p}{(}\PYG{n}{img}\PYG{p}{,} \PYG{n}{parameter}\PYG{p}{)}\PYG{p}{;}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print} \PYG{n}{res}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{.}\PYG{n}{shape}
\end{Verbatim}


\strong{See also:}


{\hyperref[api/ClearMap.ImageProcessing:module-ClearMap.ImageProcessing]{\emph{\code{ImageProcessing}}}}


\index{detectCells() (in module ClearMap.ImageProcessing.CellDetection)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.ImageProcessing:ClearMap.ImageProcessing.CellDetection.detectCells}\pysiglinewithargsret{\bfcode{detectCells}}{\emph{source}, \emph{sink=None}, \emph{method='SpotDetection'}, \emph{processMethod=\textless{}built-in function all\textgreater{}}, \emph{verbose=False}, \emph{**parameter}}{}
Detect cells in data

This is a main script to start running the cell detection.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{source} (\emph{str or array}) --
Image source

\item {} 
\textbf{sink} (\emph{str or None}) --
destination for the results

\item {} 
\textbf{method} (\emph{str or function}) --

\begin{tabulary}{\linewidth}{|L|L|}
\hline
\textsf{\relax 
Method
} & \textsf{\relax 
Description
}\\
\hline
``SpotDetection''
 & 
uses predefined spot detection pipline
\\
\hline
``Ilastik''
 & 
uses predefined pipline with cell classification via Ilastik
\\
\hline
function
 & 
a user defined function
\\
\hline\end{tabulary}


\item {} 
\textbf{processMethod} (\emph{str or all}) --
`sequential' or `parallel'. if all its choosen
automatically

\item {} 
\textbf{verbose} (\emph{bool}) --
print info

\item {} 
\textbf{**parameter} (\emph{dict}) --
parameter for the image procesing sub-routines

\end{itemize}

\end{description}\end{quote}

Returns:

\end{fulllineitems}



\paragraph{ClearMap.ImageProcessing.CellSizeDetection module}
\label{api/ClearMap.ImageProcessing:module-ClearMap.ImageProcessing.CellSizeDetection}\label{api/ClearMap.ImageProcessing:clearmap-imageprocessing-cellsizedetection-module}\index{ClearMap.ImageProcessing.CellSizeDetection (module)}
Cell shape and size detection routines

The cell shape detection is based on a seeded and masked watershed.
\index{detectCellShape() (in module ClearMap.ImageProcessing.CellSizeDetection)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.ImageProcessing:ClearMap.ImageProcessing.CellSizeDetection.detectCellShape}\pysiglinewithargsret{\bfcode{detectCellShape}}{\emph{img}, \emph{peaks}, \emph{detectCellShapeParameter=None}, \emph{threshold=None}, \emph{save=None}, \emph{verbose=False}, \emph{subStack=None}, \emph{out=\textless{}open file `\textless{}stdout\textgreater{}'}, \emph{mode `w'\textgreater{}}, \emph{**parameter}}{}
Find cell shapes as labeled image
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{img} (\emph{array}) --
image data

\item {} 
\textbf{peaks} (\emph{array}) --
point data of cell centers / seeds

\item {} 
\textbf{detectCellShape} (\emph{dict}) --

\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textsf{\relax 
Name
} & \textsf{\relax 
Type
} & \textsf{\relax 
Descritption
}\\
\hline
\emph{threshold}
 & 
(float or None)
 & 
threshold to determine mask, pixel below this are background
if None no mask is generated
\\
\hline
\emph{save}
 & 
(tuple)
 & 
size of the box on which to perform the \emph{method}
\\
\hline
\emph{verbose}
 & 
(bool or int)
 & 
print / plot information about this step
\\
\hline\end{tabulary}


\item {} 
\textbf{verbose} (\emph{bool}) --
print progress info

\item {} 
\textbf{out} (\emph{object}) --
object to write progress info to

\end{itemize}

\item[{Returns}] \leavevmode
\emph{array} --
labeled image where each label indicates a cell

\end{description}\end{quote}

\end{fulllineitems}

\index{findCellSize() (in module ClearMap.ImageProcessing.CellSizeDetection)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.ImageProcessing:ClearMap.ImageProcessing.CellSizeDetection.findCellSize}\pysiglinewithargsret{\bfcode{findCellSize}}{\emph{imglabel}, \emph{findCelSizeParameter=None}, \emph{maxLabel=None}, \emph{verbose=False}, \emph{out=\textless{}open file `\textless{}stdout\textgreater{}'}, \emph{mode `w'\textgreater{}}, \emph{**parameter}}{}
Find cell size given cell shapes as labled image
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{imglabel} (\emph{array or str}) --
labeled image, where each cell has its own label

\item {} 
\textbf{findCelSizeParameter} (\emph{dict}) --

\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textsf{\relax 
Name
} & \textsf{\relax 
Type
} & \textsf{\relax 
Descritption
}\\
\hline
\emph{maxLabel}
 & 
(int or None)
 & 
maximal label to include, if None determine automatically
\\
\hline
\emph{verbose}
 & 
(bool or int)
 & 
print / plot information about this step
\\
\hline\end{tabulary}


\item {} 
\textbf{verbose} (\emph{bool}) --
print progress info

\item {} 
\textbf{out} (\emph{object}) --
object to write progress info to

\end{itemize}

\item[{Returns}] \leavevmode
\emph{array} --
measured intensities

\end{description}\end{quote}

\end{fulllineitems}

\index{findCellIntensity() (in module ClearMap.ImageProcessing.CellSizeDetection)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.ImageProcessing:ClearMap.ImageProcessing.CellSizeDetection.findCellIntensity}\pysiglinewithargsret{\bfcode{findCellIntensity}}{\emph{img}, \emph{imglabel}, \emph{findCellIntensityParameter=None}, \emph{maxLabel=None}, \emph{method='Sum'}, \emph{verbose=False}, \emph{out=\textless{}open file `\textless{}stdout\textgreater{}'}, \emph{mode `w'\textgreater{}}, \emph{**parameter}}{}
Find integrated cell intensity given cell shapes as labled image
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{img} (\emph{array or str}) --
image data

\item {} 
\textbf{imglabel} (\emph{array or str}) --
labeled image, where each cell has its own label

\item {} 
\textbf{findCellIntensityParameter} (\emph{dict}) --

\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textsf{\relax 
Name
} & \textsf{\relax 
Type
} & \textsf{\relax 
Descritption
}\\
\hline
\emph{maxLabel}
 & 
(int or None)
 & 
maximal label to include, if None determine automatically
\\
\hline
\emph{method}
 & 
(str)
 & 
method to use for measurment: `Sum', `Mean', `Max', `Min'
\\
\hline
\emph{verbose}
 & 
(bool or int)
 & 
print / plot information about this step
\\
\hline\end{tabulary}


\item {} 
\textbf{verbose} (\emph{bool}) --
print progress info

\item {} 
\textbf{out} (\emph{object}) --
object to write progress info to

\end{itemize}

\item[{Returns}] \leavevmode
\emph{array} --
measured intensities

\end{description}\end{quote}

\end{fulllineitems}



\paragraph{Subpackages}
\label{api/ClearMap.ImageProcessing:subpackages}

\subparagraph{ClearMap.ImageProcessing.Filter package}
\label{api/ClearMap.ImageProcessing.Filter:module-ClearMap.ImageProcessing.Filter}\label{api/ClearMap.ImageProcessing.Filter::doc}\label{api/ClearMap.ImageProcessing.Filter:clearmap-imageprocessing-filter-package}\index{ClearMap.ImageProcessing.Filter (module)}
This sub-package provides various volumetric filter kernels and structure elments

A set of linear filters can be applied to the data using
{\hyperref[api/ClearMap.ImageProcessing.Filter:module-ClearMap.ImageProcessing.Filter.LinearFilter]{\emph{\code{LinearFilter}}}}.

Because its utility for cell detection the difference of Gaussians filter
is implemented directly in {\hyperref[api/ClearMap.ImageProcessing.Filter:module-ClearMap.ImageProcessing.Filter.DoGFilter]{\emph{\code{DoGFilter}}}}.

The fitler kernels defined in {\hyperref[api/ClearMap.ImageProcessing.Filter:module-ClearMap.ImageProcessing.Filter.FilterKernel]{\emph{\code{FilterKernel}}}}
can be used in combination with the \code{Convolution}
module.

Structured elements defined in
\code{StructureElements} can be used in
combination with various morphological operations, e.g. used in the
:mod:\textasciitilde{}ClearMap.ImageProcessing.BackgroundRemoval{}` module.


\subparagraph{ClearMap.ImageProcessing.Filter.LinearFilter module}
\label{api/ClearMap.ImageProcessing.Filter:module-ClearMap.ImageProcessing.Filter.LinearFilter}\label{api/ClearMap.ImageProcessing.Filter:clearmap-imageprocessing-filter-linearfilter-module}\index{ClearMap.ImageProcessing.Filter.LinearFilter (module)}
Linear filter module
\index{filterLinear() (in module ClearMap.ImageProcessing.Filter.LinearFilter)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.ImageProcessing.Filter:ClearMap.ImageProcessing.Filter.LinearFilter.filterLinear}\pysiglinewithargsret{\bfcode{filterLinear}}{\emph{img}, \emph{filterLinearParameter=None}, \emph{ftype=None}, \emph{size=None}, \emph{sigma=None}, \emph{sigma2=None}, \emph{save=None}, \emph{subStack=None}, \emph{verbose=False}, \emph{out=\textless{}open file `\textless{}stdout\textgreater{}'}, \emph{mode `w'\textgreater{}}, \emph{**parameter}}{}
Applies a linear filter to the image
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{img} (\emph{array}) --
image data

\item {} 
\textbf{filterLinearParameter} (\emph{dict}) --

\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textsf{\relax 
Name
} & \textsf{\relax 
Type
} & \textsf{\relax 
Descritption
}\\
\hline
\emph{ftype}
 & 
(str or None)
 & 
the type of the filter, see {\hyperref[api/ClearMap.ImageProcessing.Filter:filtertypes]{\emph{Filter Type}}}
if None do ot perform any fitlering
\\
\hline
\emph{size}
 & 
(tuple or None)
 & 
size for the filter
if None, do not perform filtering
\\
\hline
\emph{sigma}
 & 
(tuple or None)
 & 
std of outer Guassian, if None autmatically determined from size
\\
\hline
\emph{sigma2}
 & 
(tuple or None)
 & 
std of inner Guassian, if None autmatically determined from size
\\
\hline
\emph{save}
 & 
(str or None)
 & 
file name to save result of this operation
if None dont save to file
\\
\hline
\emph{verbose}
 & 
(bool or int)
 & 
print progress information
\\
\hline\end{tabulary}


\item {} 
\textbf{subStack} (\emph{dict or None}) --
sub-stack information

\item {} 
\textbf{verbose} (\emph{bool}) --
print progress info

\item {} 
\textbf{out} (\emph{object}) --
object to write progress info to

\end{itemize}

\item[{Returns}] \leavevmode
\emph{array} --
filtered image

\end{description}\end{quote}

\begin{notice}{note}{Note:}
Converts image to float32 type if filter is active!
\end{notice}

\end{fulllineitems}



\subparagraph{ClearMap.ImageProcessing.Filter.DoGFilter module}
\label{api/ClearMap.ImageProcessing.Filter:module-ClearMap.ImageProcessing.Filter.DoGFilter}\label{api/ClearMap.ImageProcessing.Filter:clearmap-imageprocessing-filter-dogfilter-module}\index{ClearMap.ImageProcessing.Filter.DoGFilter (module)}
DoG filter module
\index{filterDoG() (in module ClearMap.ImageProcessing.Filter.DoGFilter)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.ImageProcessing.Filter:ClearMap.ImageProcessing.Filter.DoGFilter.filterDoG}\pysiglinewithargsret{\bfcode{filterDoG}}{\emph{img}, \emph{filterDoGParameter=None}, \emph{size=None}, \emph{sigma=None}, \emph{sigma2=None}, \emph{save=None}, \emph{verbose=None}, \emph{subStack=None}, \emph{out=\textless{}open file `\textless{}stdout\textgreater{}'}, \emph{mode `w'\textgreater{}}, \emph{**parameter}}{}
Difference of Gaussians (DoG) filter step
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{img} (\emph{array}) --
image data

\item {} 
\textbf{filterDoGParameter} (\emph{dict}) --

\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textsf{\relax 
Name
} & \textsf{\relax 
Type
} & \textsf{\relax 
Descritption
}\\
\hline
\emph{size}
 & 
(tuple or None)
 & 
size for the DoG filter
if None, do not correct for any background
\\
\hline
\emph{sigma}
 & 
(tuple or None)
 & 
std of outer Guassian, if None autmatically determined from size
\\
\hline
\emph{sigma2}
 & 
(tuple or None)
 & 
std of inner Guassian, if None autmatically determined from size
\\
\hline
\emph{save}
 & 
(str or None)
 & 
file name to save result of this operation
if None dont save to file
\\
\hline
\emph{verbose}
 & 
(bool or int)
 & 
print progress information
\\
\hline\end{tabulary}


\item {} 
\textbf{subStack} (\emph{dict or None}) --
sub-stack information

\item {} 
\textbf{out} (\emph{object}) --
object to write progress info to

\end{itemize}

\item[{Returns}] \leavevmode
\emph{array} --
DoG filtered image

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{ClearMap.ImageProcessing.Filter.Convolution module}
\label{api/ClearMap.ImageProcessing.Filter:module-ClearMap.ImageProcessing.Filter.Convolution}\label{api/ClearMap.ImageProcessing.Filter:clearmap-imageprocessing-filter-convolution-module}\index{ClearMap.ImageProcessing.Filter.Convolution (module)}
Convolve volumetric data with a 3d kernel, optimized for memory / float32 use

Based on \href{http://docs.scipy.org/doc/scipy/reference/signal.html}{scipy.signal}
routines.

Author
\begin{quote}

Original code from \href{http://docs.scipy.org/doc/scipy/reference/signal.html}{scipy.signal}.

Modified by Chirstoph Kirst to optimize memory and sped and integration into ClearMap.
The Rockefeller University, New York City, 2015
\end{quote}
\index{convolve() (in module ClearMap.ImageProcessing.Filter.Convolution)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.ImageProcessing.Filter:ClearMap.ImageProcessing.Filter.Convolution.convolve}\pysiglinewithargsret{\bfcode{convolve}}{\emph{x}, \emph{k}, \emph{mode='same'}}{}
Convolve array with kernel using float32 / complex64, optimized for memory consumption and speed
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{x} (\emph{array}) --
data to be convolved

\item {} 
\textbf{k} (\emph{array}) --
filter kernel

\end{itemize}

\item[{Returns}] \leavevmode
\emph{array} --
convolution

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{ClearMap.ImageProcessing.Filter.FilterKernel module}
\label{api/ClearMap.ImageProcessing.Filter:clearmap-imageprocessing-filter-filterkernel-module}\label{api/ClearMap.ImageProcessing.Filter:module-ClearMap.ImageProcessing.Filter.FilterKernel}\index{ClearMap.ImageProcessing.Filter.FilterKernel (module)}
Implementation of various volumetric filter kernels


\subparagraph{Filter Type}
\label{api/ClearMap.ImageProcessing.Filter:filtertypes}\label{api/ClearMap.ImageProcessing.Filter:filter-type}
Filter types defined by the \code{ftype} key include:

\begin{tabulary}{\linewidth}{|L|L|}
\hline
\textsf{\relax 
Type
} & \textsf{\relax 
Descrition
}\\
\hline
\code{mean}
 & 
uniform averaging filter
\\
\hline
\code{gaussian}
 & 
Gaussian filter
\\
\hline
\code{log}
 & 
Laplacian of Gaussian filter (LoG)
\\
\hline
\code{dog}
 & 
Difference of Gaussians filter (DoG)
\\
\hline
\code{sphere}
 & 
Sphere filter
\\
\hline
\code{disk}
 & 
Disk filter
\\
\hline\end{tabulary}

\index{filterKernel() (in module ClearMap.ImageProcessing.Filter.FilterKernel)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.ImageProcessing.Filter:ClearMap.ImageProcessing.Filter.FilterKernel.filterKernel}\pysiglinewithargsret{\bfcode{filterKernel}}{\emph{ftype='Gaussian'}, \emph{size=(5}, \emph{5)}, \emph{sigma=None}, \emph{radius=None}, \emph{sigma2=None}}{}
Creates a filter kernel of a special type
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{ftype} (\emph{str}) --
filter type, see {\hyperref[api/ClearMap.ImageProcessing.Filter:filtertypes]{\emph{Filter Type}}}

\item {} 
\textbf{size} (\emph{array or tuple}) --
size of the filter kernel

\item {} 
\textbf{sigma} (\emph{tuple or float}) --
std for the first gaussian (if present)

\item {} 
\textbf{radius} (\emph{tuple or float}) --
radius of the kernel (if applicable)

\item {} 
\textbf{sigma2} (\emph{tuple or float}) --
std of a second gaussian (if present)

\end{itemize}

\item[{Returns}] \leavevmode
\emph{array} --
structure element

\end{description}\end{quote}

\end{fulllineitems}

\index{filterKernel2D() (in module ClearMap.ImageProcessing.Filter.FilterKernel)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.ImageProcessing.Filter:ClearMap.ImageProcessing.Filter.FilterKernel.filterKernel2D}\pysiglinewithargsret{\bfcode{filterKernel2D}}{\emph{ftype='Gaussian'}, \emph{size=(5}, \emph{5)}, \emph{sigma=None}, \emph{sigma2=None}, \emph{radius=None}}{}
Creates a 2d filter kernel of a special type
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{ftype} (\emph{str}) --
filter type, see {\hyperref[api/ClearMap.ImageProcessing.Filter:filtertypes]{\emph{Filter Type}}}

\item {} 
\textbf{size} (\emph{array or tuple}) --
size of the filter kernel

\item {} 
\textbf{sigma} (\emph{tuple or float}) --
std for the first gaussian (if present)

\item {} 
\textbf{radius} (\emph{tuple or float}) --
radius of the kernel (if applicable)

\item {} 
\textbf{sigma2} (\emph{tuple or float}) --
std of a second gaussian (if present)

\end{itemize}

\item[{Returns}] \leavevmode
\emph{array} --
structure element

\end{description}\end{quote}

\end{fulllineitems}

\index{filterKernel3D() (in module ClearMap.ImageProcessing.Filter.FilterKernel)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.ImageProcessing.Filter:ClearMap.ImageProcessing.Filter.FilterKernel.filterKernel3D}\pysiglinewithargsret{\bfcode{filterKernel3D}}{\emph{ftype='Gaussian'}, \emph{size=(5}, \emph{5}, \emph{5)}, \emph{sigma=None}, \emph{sigma2=None}, \emph{radius=None}}{}
Creates a 3d filter kernel of a special type
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{ftype} (\emph{str}) --
filter type, see {\hyperref[api/ClearMap.ImageProcessing.Filter:filtertypes]{\emph{Filter Type}}}

\item {} 
\textbf{size} (\emph{array or tuple}) --
size of the filter kernel

\item {} 
\textbf{sigma} (\emph{tuple or float}) --
std for the first gaussian (if present)

\item {} 
\textbf{radius} (\emph{tuple or float}) --
radius of the kernel (if applicable)

\item {} 
\textbf{sigma2} (\emph{tuple or float}) --
std of a second gaussian (if present)

\end{itemize}

\item[{Returns}] \leavevmode
\emph{array} --
structure element

\end{description}\end{quote}

\end{fulllineitems}

\index{test() (in module ClearMap.ImageProcessing.Filter.FilterKernel)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.ImageProcessing.Filter:ClearMap.ImageProcessing.Filter.FilterKernel.test}\pysiglinewithargsret{\bfcode{test}}{}{}
Test FilterKernel module

\end{fulllineitems}



\subparagraph{ClearMap.ImageProcessing.Filter.StructureElement module}
\label{api/ClearMap.ImageProcessing.Filter:clearmap-imageprocessing-filter-structureelement-module}\label{api/ClearMap.ImageProcessing.Filter:module-ClearMap.ImageProcessing.Filter.StructureElement}\index{ClearMap.ImageProcessing.Filter.StructureElement (module)}
Routines to generate various structure elements

Structured elements defined by the \code{setype} key include:


\subparagraph{Structure Element Types}
\label{api/ClearMap.ImageProcessing.Filter:structureelementtypes}\label{api/ClearMap.ImageProcessing.Filter:structure-element-types}
\begin{tabulary}{\linewidth}{|L|L|}
\hline
\textsf{\relax 
Type
} & \textsf{\relax 
Descrition
}\\
\hline
\code{sphere}
 & 
Sphere structure
\\
\hline
\code{disk}
 & 
Disk structure
\\
\hline\end{tabulary}


\begin{notice}{note}{Note:}
To be extended!
\end{notice}
\index{structureElement() (in module ClearMap.ImageProcessing.Filter.StructureElement)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.ImageProcessing.Filter:ClearMap.ImageProcessing.Filter.StructureElement.structureElement}\pysiglinewithargsret{\bfcode{structureElement}}{\emph{setype='Disk'}, \emph{sesize=(3}, \emph{3)}}{}
Creates specific 2d and 3d structuring elements
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{setype} (\emph{str}) --
structure element type, see {\hyperref[api/ClearMap.ImageProcessing.Filter:structureelementtypes]{\emph{Structure Element Types}}}

\item {} 
\textbf{sesize} (\emph{array or tuple}) --
size of the structure element

\end{itemize}

\item[{Returns}] \leavevmode
\emph{array} --
structure element

\end{description}\end{quote}

\end{fulllineitems}

\index{structureElementOffsets() (in module ClearMap.ImageProcessing.Filter.StructureElement)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.ImageProcessing.Filter:ClearMap.ImageProcessing.Filter.StructureElement.structureElementOffsets}\pysiglinewithargsret{\bfcode{structureElementOffsets}}{\emph{sesize}}{}
Calculates offsets for a structural element given its size
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{sesize} (\emph{array or tuple}) --
size of the structure element

\item[{Returns}] \leavevmode
\emph{array} --
offsets to center taking care of even/odd ummber of elements

\end{description}\end{quote}

\end{fulllineitems}

\index{structureElement2D() (in module ClearMap.ImageProcessing.Filter.StructureElement)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.ImageProcessing.Filter:ClearMap.ImageProcessing.Filter.StructureElement.structureElement2D}\pysiglinewithargsret{\bfcode{structureElement2D}}{\emph{setype='Disk'}, \emph{sesize=(3}, \emph{3)}}{}
Creates specific 2d structuring elements
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{setype} (\emph{str}) --
structure element type, see {\hyperref[api/ClearMap.ImageProcessing.Filter:structureelementtypes]{\emph{Structure Element Types}}}

\item {} 
\textbf{sesize} (\emph{array or tuple}) --
size of the structure element

\end{itemize}

\item[{Returns}] \leavevmode
\emph{array} --
structure element

\end{description}\end{quote}

\end{fulllineitems}

\index{structureElement3D() (in module ClearMap.ImageProcessing.Filter.StructureElement)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.ImageProcessing.Filter:ClearMap.ImageProcessing.Filter.StructureElement.structureElement3D}\pysiglinewithargsret{\bfcode{structureElement3D}}{\emph{setype='Disk'}, \emph{sesize=(3}, \emph{3}, \emph{3)}}{}
Creates specific 3d structuring elements
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{setype} (\emph{str}) --
structure element type, see {\hyperref[api/ClearMap.ImageProcessing.Filter:structureelementtypes]{\emph{Structure Element Types}}}

\item {} 
\textbf{sesize} (\emph{array or tuple}) --
size of the structure element

\end{itemize}

\item[{Returns}] \leavevmode
\emph{array} --
structure element

\end{description}\end{quote}

\end{fulllineitems}



\paragraph{ClearMap.ImageProcessing.IlluminationCorrection module}
\label{api/ClearMap.ImageProcessing:clearmap-imageprocessing-illuminationcorrection-module}\label{api/ClearMap.ImageProcessing:module-ClearMap.ImageProcessing.IlluminationCorrection}\index{ClearMap.ImageProcessing.IlluminationCorrection (module)}
Illumination correction toolbox.

The module provides a function to correct illumination/vignetting systematic
variations in intensity.

The intensity image \(I(x)\) given a flat field \(F(x)\) and
a background \(B(x)\) the image is corrected to \(C(x)\) as:

The module also has functionality to create flat field corections from measured
intensity changes in a single direction, useful e.g. for lightsheet images,
see e.g. {\hyperref[api/ClearMap.ImageProcessing:ClearMap.ImageProcessing.IlluminationCorrection.flatfieldLineFromRegression]{\emph{\code{flatfieldLineFromRegression()}}}}.
\paragraph{References}

Fundamentals of Light Microscopy and Electronic Imaging, p. 421
\index{DefaultFlatFieldLineFile (in module ClearMap.ImageProcessing.IlluminationCorrection)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.ImageProcessing:ClearMap.ImageProcessing.IlluminationCorrection.DefaultFlatFieldLineFile}\pysigline{\bfcode{DefaultFlatFieldLineFile}\strong{ = `/home/ckirst/Science/Projects/BrainActivityMap/Analysis/ClearMap/Data/lightsheet\_flatfield\_correction.csv'}}
Default file of points along the illumination changing line for the flat field correction


\strong{See also:}


{\hyperref[api/ClearMap.ImageProcessing:ClearMap.ImageProcessing.IlluminationCorrection.correctIllumination]{\emph{\code{correctIllumination()}}}}



\end{fulllineitems}

\index{correctIllumination() (in module ClearMap.ImageProcessing.IlluminationCorrection)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.ImageProcessing:ClearMap.ImageProcessing.IlluminationCorrection.correctIllumination}\pysiglinewithargsret{\bfcode{correctIllumination}}{\emph{img}, \emph{correctIlluminationParameter=None}, \emph{flatfield=None}, \emph{background=None}, \emph{scaling=None}, \emph{save=None}, \emph{verbose=False}, \emph{subStack=None}, \emph{out=\textless{}open file `\textless{}stdout\textgreater{}'}, \emph{mode `w'\textgreater{}}, \emph{**parameter}}{}
Correct illumination variations
\begin{quote}

The intensity image \(I(x)\) given a flat field \(F(x)\) and
a background \(B(x)\) the image is corrected to \(C(x)\) as:

If the background is not given \(B(x) = 0\).

The correction is done slice by slice assuming the data was collected with
a light sheet microscope.

The image is finally optionally scaled.
\end{quote}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{img} (\emph{array}) --
image data

\item {} 
\textbf{findCenterOfMaximaParameter} (\emph{dict}) --

\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textsf{\relax 
Name
} & \textsf{\relax 
Type
} & \textsf{\relax 
Descritption
}\\
\hline
\emph{flatfield}
 & 
(str, None or array)
 & 
flat field intensities, if None d onot correct image for
illumination, if True the
\\
\hline
\emph{background}
 & 
(str, None or array)
 & 
background image as file name or array
if None background is assumed to be zero
\\
\hline
\emph{scaling}
 & 
(str or None)
 & 
scale the corrected result by this factor
if `max'/'mean' scale to keep max/mean invariant
\\
\hline
\emph{save}
 & 
(str or None)
 & 
save the corrected image to file
\\
\hline
\emph{verbose}
 & 
(bool or int)
 & 
print / plot information about this step
\\
\hline\end{tabulary}


\item {} 
\textbf{subStack} (\emph{dict or None}) --
sub-stack information

\item {} 
\textbf{verbose} (\emph{bool}) --
print progress info

\item {} 
\textbf{out} (\emph{object}) --
object to write progress info to

\end{itemize}

\item[{Returns}] \leavevmode
\emph{array} --
illumination corrected image

\end{description}\end{quote}
\paragraph{References}

Fundamentals of Light Microscopy and Electronic Imaging, p 421


\strong{See also:}


{\hyperref[api/ClearMap.ImageProcessing:ClearMap.ImageProcessing.IlluminationCorrection.DefaultFlatFieldLineFile]{\emph{\code{DefaultFlatFieldLineFile}}}}



\end{fulllineitems}

\index{flatfieldFromLine() (in module ClearMap.ImageProcessing.IlluminationCorrection)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.ImageProcessing:ClearMap.ImageProcessing.IlluminationCorrection.flatfieldFromLine}\pysiglinewithargsret{\bfcode{flatfieldFromLine}}{\emph{line}, \emph{xsize}}{}
Creates a 2d flat field image from a 1d line of estimated intensities
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{lines} (\emph{array}) --
array of intensities along y axis

\item {} 
\textbf{xsize} (\emph{int}) --
size of image in x dimension

\end{itemize}

\item[{Returns}] \leavevmode
\emph{array} --
full 2d flat field

\end{description}\end{quote}

\end{fulllineitems}

\index{flatfieldLineFromRegression() (in module ClearMap.ImageProcessing.IlluminationCorrection)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.ImageProcessing:ClearMap.ImageProcessing.IlluminationCorrection.flatfieldLineFromRegression}\pysiglinewithargsret{\bfcode{flatfieldLineFromRegression}}{\emph{data}, \emph{sink=None}, \emph{method='polynomial'}, \emph{reverse=None}, \emph{verbose=False}}{}
Create flat field line fit from a list of positions and intensities

The fit is either to be assumed to be a Gaussian:

or follows a order 6 radial polynomial
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{data} (\emph{array}) --
intensity data as vector of intensities or (n,2) dim array of positions d=0 and intensities measurements d=1:-1

\item {} 
\textbf{sink} (\emph{str or None}) --
destination to write the result of the fit

\item {} 
\textbf{method} (\emph{str}) --
method to fit intensity data, `Gaussian' or `Polynomial'

\item {} 
\textbf{reverse} (\emph{bool}) --
reverse the line fit after fitting

\item {} 
\textbf{verbose} (\emph{bool}) --
print and plot information for the fit

\end{itemize}

\item[{Returns}] \leavevmode
\emph{array} --
fitted intensities on points

\end{description}\end{quote}

\end{fulllineitems}



\paragraph{ClearMap.ImageProcessing.BackgroundRemoval module}
\label{api/ClearMap.ImageProcessing:module-ClearMap.ImageProcessing.BackgroundRemoval}\label{api/ClearMap.ImageProcessing:clearmap-imageprocessing-backgroundremoval-module}\index{ClearMap.ImageProcessing.BackgroundRemoval (module)}
Functions to remove background in images

The main routine subtracts a morphological opening from the original image
for background removal.
\index{removeBackground() (in module ClearMap.ImageProcessing.BackgroundRemoval)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.ImageProcessing:ClearMap.ImageProcessing.BackgroundRemoval.removeBackground}\pysiglinewithargsret{\bfcode{removeBackground}}{\emph{img}, \emph{removeBackgroundParameter=None}, \emph{size=None}, \emph{save=None}, \emph{verbose=False}, \emph{subStack=None}, \emph{out=\textless{}open file `\textless{}stdout\textgreater{}'}, \emph{mode `w'\textgreater{}}, \emph{**parameter}}{}
Remove background via subtracting a morphological opening from the original image

Background removal is done z-slice by z-slice.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{img} (\emph{array}) --
image data

\item {} 
\textbf{removeBackGroundParameter} (\emph{dict}) --

\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textsf{\relax 
Name
} & \textsf{\relax 
Type
} & \textsf{\relax 
Descritption
}\\
\hline
\emph{size}
 & 
(tuple or None)
 & 
size for the structure element of the morphological opening
if None, do not correct for any background
\\
\hline
\emph{save}
 & 
(str or None)
 & 
file name to save result of this operation
if None dont save to file
\\
\hline
\emph{verbose}
 & 
(bool or int)
 & 
print / plot information about this step
\\
\hline\end{tabulary}


\item {} 
\textbf{subStack} (\emph{dict or None}) --
sub-stack information

\item {} 
\textbf{verbose} (\emph{bool}) --
print progress info

\item {} 
\textbf{out} (\emph{object}) --
object to write progress info to

\end{itemize}

\item[{Returns}] \leavevmode
\emph{array} --
background corrected image

\end{description}\end{quote}

\end{fulllineitems}



\paragraph{ClearMap.ImageProcessing.GreyReconstruction module}
\label{api/ClearMap.ImageProcessing:clearmap-imageprocessing-greyreconstruction-module}\phantomsection\label{api/ClearMap.ImageProcessing:module-ClearMap.ImageProcessing.GreyReconstruction}\index{ClearMap.ImageProcessing.GreyReconstruction (module)}
Grey reconstruction module

This morphological reconstruction routine was adapted from
\href{http://www.cellprofiler.org}{CellProfiler}.

Author
\begin{quote}

Original author: Lee Kamentsky
Copyright (c) 2003-2009 Massachusetts Institute of Technology
Copyright (c) 2009-2011 Broad Institute

Modified by Chirstoph Kirst to optimize integration
into ClearMap, The Rockefeller University, New York City, 2015
\end{quote}
\index{reconstruct() (in module ClearMap.ImageProcessing.GreyReconstruction)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.ImageProcessing:ClearMap.ImageProcessing.GreyReconstruction.reconstruct}\pysiglinewithargsret{\bfcode{reconstruct}}{\emph{seed}, \emph{mask}, \emph{method='dilation'}, \emph{selem=None}, \emph{offset=None}}{}
Performs a morphological reconstruction of an image.

Reconstruction uses a seed image, which specifies the values
to dilate and a mask image that gives the maximum allowed dilated value at
each pixel.

The algorithm is taken from \footnote[1]{
Robinson, ``Efficient morphological reconstruction: a downhill
filter'', Pattern Recognition Letters 25 (2004) 1759-1767.
}. Applications for greyscale
reconstruction are discussed in \footnote[2]{
Vincent, L., ``Morphological Grayscale Reconstruction in Image
Analysis: Applications and Efficient Algorithms'', IEEE Transactions
on Image Processing (1993)
} and \footnote[3]{
Soille, P., ``Morphological Image Analysis: Principles and
Applications'', Chapter 6, 2nd edition (2003), ISBN 3540429883.
}.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{seed} (\emph{array}) --
seed image to be dilated or eroded.

\item {} 
\textbf{mask} (\emph{array}) --
maximum (dilation) / minimum (erosion) allowed

\item {} 
\textbf{method} (\emph{str}) --
\{`dilation'\textbar{}'erosion'\}

\item {} 
\textbf{selem} (\emph{array}) --
structuring element

\item {} 
\textbf{offset} (\emph{array or None}) --
offset of the structuring element, None is centered

\end{itemize}

\item[{Returns}] \leavevmode
\emph{array} --
result of morphological reconstruction.

\end{description}\end{quote}

\begin{notice}{note}{Note:}
Operates on 2d images.
\end{notice}

Reference:

\end{fulllineitems}

\index{greyReconstruction() (in module ClearMap.ImageProcessing.GreyReconstruction)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.ImageProcessing:ClearMap.ImageProcessing.GreyReconstruction.greyReconstruction}\pysiglinewithargsret{\bfcode{greyReconstruction}}{\emph{img}, \emph{mask}, \emph{greyReconstructionParameter=None}, \emph{method=None}, \emph{size=3}, \emph{save=None}, \emph{verbose=False}, \emph{subStack=None}, \emph{out=\textless{}open file `\textless{}stdout\textgreater{}'}, \emph{mode `w'\textgreater{}}, \emph{**parameter}}{}
Calculates the grey reconstruction of the image

Reconstruction is done z-slice by z-slice.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{img} (\emph{array}) --
image data

\item {} 
\textbf{removeBackGroundParameter} (\emph{dict}) --

\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textsf{\relax 
Name
} & \textsf{\relax 
Type
} & \textsf{\relax 
Descritption
}\\
\hline
\emph{method}
 & 
(tuple or None)
 & 
`dilation' or `erosion', if None return original image
\\
\hline
\emph{size}
 & 
(int or tuple)
 & 
size of structuring element
\\
\hline
\emph{save}
 & 
(str or None)
 & 
file name to save result of this operation
if None dont save to file
\\
\hline
\emph{verbose}
 & 
(bool or int)
 & 
print / plot information about this step
\\
\hline\end{tabulary}


\item {} 
\textbf{subStack} (\emph{dict or None}) --
sub-stack information

\item {} 
\textbf{verbose} (\emph{bool}) --
print progress info

\item {} 
\textbf{out} (\emph{object}) --
object to write progress info to

\end{itemize}

\item[{Returns}] \leavevmode
\emph{array} --
grey reconstructed image

\end{description}\end{quote}

\end{fulllineitems}



\paragraph{ClearMap.ImageProcessing.SpotDetection module}
\label{api/ClearMap.ImageProcessing:clearmap-imageprocessing-spotdetection-module}\phantomsection\label{api/ClearMap.ImageProcessing:module-ClearMap.ImageProcessing.SpotDetection}\index{ClearMap.ImageProcessing.SpotDetection (module)}
Functions to detect spots in images

The main routine \code{detectCells()} uses a difference of gaussian filter (see
:mod:{\color{red}\bfseries{}{}`}\textasciitilde{}ClearMap.ImageProcessing.Filter) followed by a peak detection step.
\paragraph{Example}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{os}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{ClearMap.IO} \PYG{k+kn}{as} \PYG{n+nn}{io}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{ClearMap.Settings} \PYG{k+kn}{as} \PYG{n+nn}{settings}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{ClearMap.ImageProcessing.SpotDetection} \PYG{k+kn}{as} \PYG{n+nn}{sd}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{fn} \PYG{o}{=} \PYG{n}{os}\PYG{o}{.}\PYG{n}{path}\PYG{o}{.}\PYG{n}{join}\PYG{p}{(}\PYG{n}{settings}\PYG{o}{.}\PYG{n}{ClearMapPath}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Test/Data/Synthetic/test\PYGZus{}iDISCO\PYGZus{}}\PYG{l+s}{\PYGZbs{}}\PYG{l+s}{d\PYGZob{}3\PYGZcb{}.tif}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{img} \PYG{o}{=} \PYG{n}{io}\PYG{o}{.}\PYG{n}{readData}\PYG{p}{(}\PYG{n}{fn}\PYG{p}{)}\PYG{p}{;}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{img} \PYG{o}{=} \PYG{n}{img}\PYG{o}{.}\PYG{n}{astype}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{int16}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{;} \PYG{c}{\PYGZsh{} converting data to smaller integer types can be more memory efficient!}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{res} \PYG{o}{=} \PYG{n}{sd}\PYG{o}{.}\PYG{n}{detectSpots}\PYG{p}{(}\PYG{n}{img}\PYG{p}{,} \PYG{n}{dogSize} \PYG{o}{=} \PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{,} \PYG{n}{flatfield} \PYG{o}{=} \PYG{n+nb+bp}{None}\PYG{p}{,} \PYG{n}{threshold} \PYG{o}{=} \PYG{l+m+mi}{5}\PYG{p}{,} \PYG{n}{cellShapeThreshold} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Found }\PYG{l+s+si}{\PYGZpc{}d}\PYG{l+s}{ cells !}\PYG{l+s}{\PYGZsq{}} \PYG{o}{\PYGZpc{}} \PYG{n}{res}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
\PYG{g+go}{Illumination: flatfield          : None}
\PYG{g+go}{Illumination: illuminationScaling: True}
\PYG{g+go}{Illumination: background         : None}
\PYG{g+go}{Background: backgroundSize: (15, 15)}
\PYG{g+go}{Background: elapsed time: 0:00:00}
\PYG{g+go}{DoG: dogSize: (5, 5, 5)}
\PYG{g+go}{DoG: elapsed time: 0:00:00}
\PYG{g+go}{Extended Max: threshold   : 5}
\PYG{g+go}{Extended Max: localMaxSize: 5}
\PYG{g+go}{Extended Max: hMax        : None}
\PYG{g+go}{Extended Max: elapsed time: 0:00:00}
\PYG{g+go}{Cell Centers: elapsed time: 0:00:00}
\PYG{g+go}{Cell Shape: cellShapeThreshold: 1}
\PYG{g+go}{Cell Shape:: elapsed time: 0:00:00}
\PYG{g+go}{Cell Size:: elapsed time: 0:00:00}
\PYG{g+go}{Cell Intensity: cellIntensityMethod: Max}
\PYG{g+go}{Cell Intensity:: elapsed time: 0:00:00}
\PYG{g+go}{Cell Intensity: cellIntensityMethod: Max}
\PYG{g+go}{Cell Intensity:: elapsed time: 0:00:00}
\PYG{g+go}{Cell Intensity: cellIntensityMethod: Max}
\PYG{g+go}{Cell Intensity:: elapsed time: 0:00:00}
\PYG{g+go}{Found 38 cells !}
\end{Verbatim}

After execution this example inspect the result of the cell detection in
the folder Test/Data/CellShape/{\color{red}\bfseries{}cellshape\_}d\{3\}.tif.
\index{detectSpots() (in module ClearMap.ImageProcessing.SpotDetection)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.ImageProcessing:ClearMap.ImageProcessing.SpotDetection.detectSpots}\pysiglinewithargsret{\bfcode{detectSpots}}{\emph{img}, \emph{detectSpotsParameter=None}, \emph{correctIlluminationParameter=None}, \emph{removeBackgroundParameter=None}, \emph{filterDoGParameter=None}, \emph{findExtendedMaximaParameter=None}, \emph{detectCellShapeParameter=None}, \emph{verbose=False}, \emph{out=\textless{}open file `\textless{}stdout\textgreater{}'}, \emph{mode `w'\textgreater{}}, \emph{**parameter}}{}
Detect Cells in 3d grayscale image using DoG filtering and maxima detection
\begin{description}
\item[{Effectively this function performs the following steps:}] \leavevmode\begin{itemize}
\item {} 
illumination correction via {\hyperref[api/ClearMap.ImageProcessing:ClearMap.ImageProcessing.IlluminationCorrection.correctIllumination]{\emph{\code{correctIllumination()}}}}

\item {} 
background removal via {\hyperref[api/ClearMap.ImageProcessing:ClearMap.ImageProcessing.BackgroundRemoval.removeBackground]{\emph{\code{removeBackground()}}}}

\item {} 
difference of Gaussians (DoG) filter via \code{filterDoG()}

\item {} 
maxima detection via {\hyperref[api/ClearMap.ImageProcessing:ClearMap.ImageProcessing.MaximaDetection.findExtendedMaxima]{\emph{\code{findExtendedMaxima()}}}}

\item {} 
cell shape detection via {\hyperref[api/ClearMap.ImageProcessing:ClearMap.ImageProcessing.CellSizeDetection.detectCellShape]{\emph{\code{detectCellShape()}}}}

\item {} 
cell intensity and size measurements via: {\hyperref[api/ClearMap.ImageProcessing:ClearMap.ImageProcessing.CellSizeDetection.findCellIntensity]{\emph{\code{findCellIntensity()}}}},
{\hyperref[api/ClearMap.ImageProcessing:ClearMap.ImageProcessing.CellSizeDetection.findCellSize]{\emph{\code{findCellSize()}}}}.

\end{itemize}

\end{description}

\begin{notice}{note}{Note:}
Processing steps are done in place to save memory.
\end{notice}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{img} (\emph{array}) --
image data

\item {} 
\textbf{detectSpotParameter} --
image processing parameter as described in the individual sub-routines

\item {} 
\textbf{verbose} (\emph{bool}) --
print progress information

\item {} 
\textbf{out} (\emph{object}) --
object to print progress information to

\end{itemize}

\item[{Returns}] \leavevmode

\emph{tuple} --
tuple of arrays (cell coordinates, raw intensity, fully filtered
\begin{quote}

intensty, illumination and background corrected intensity {[}, cell size{]})
\end{quote}


\end{description}\end{quote}

\end{fulllineitems}

\index{test() (in module ClearMap.ImageProcessing.SpotDetection)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.ImageProcessing:ClearMap.ImageProcessing.SpotDetection.test}\pysiglinewithargsret{\bfcode{test}}{}{}
Test Spot Detection Module

\end{fulllineitems}



\paragraph{ClearMap.ImageProcessing.MaximaDetection module}
\label{api/ClearMap.ImageProcessing:module-ClearMap.ImageProcessing.MaximaDetection}\label{api/ClearMap.ImageProcessing:clearmap-imageprocessing-maximadetection-module}\index{ClearMap.ImageProcessing.MaximaDetection (module)}
Collection of routines to detect maxima

Used for finding cells or intensity peaks.
\index{hMaxTransform() (in module ClearMap.ImageProcessing.MaximaDetection)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.ImageProcessing:ClearMap.ImageProcessing.MaximaDetection.hMaxTransform}\pysiglinewithargsret{\bfcode{hMaxTransform}}{\emph{img}, \emph{hMax}}{}
Calculates h-maximum transform of an image
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{img} (\emph{array}) --
image

\item {} 
\textbf{hMax} (\emph{float or None}) --
h parameter of h-max transform

\end{itemize}

\item[{Returns}] \leavevmode
\emph{array} --
h-max transformed image if h is not None

\end{description}\end{quote}

\end{fulllineitems}

\index{localMax() (in module ClearMap.ImageProcessing.MaximaDetection)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.ImageProcessing:ClearMap.ImageProcessing.MaximaDetection.localMax}\pysiglinewithargsret{\bfcode{localMax}}{\emph{img}, \emph{size=5}}{}
Calculates local maxima of an image
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{img} (\emph{array}) --
image

\item {} 
\textbf{size} (\emph{float or None}) --
size of volume to search for maxima

\end{itemize}

\item[{Returns}] \leavevmode
\emph{array} --
mask that is True at local maxima

\end{description}\end{quote}

\end{fulllineitems}

\index{extendedMax() (in module ClearMap.ImageProcessing.MaximaDetection)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.ImageProcessing:ClearMap.ImageProcessing.MaximaDetection.extendedMax}\pysiglinewithargsret{\bfcode{extendedMax}}{\emph{img}, \emph{hMax=0}}{}
Calculates extened h maxima of an image

Extended maxima are the local maxima of the h-max transform
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{img} (\emph{array}) --
image

\item {} 
\textbf{hMax} (\emph{float or None}) --
h parameter of h-max transform

\end{itemize}

\item[{Returns}] \leavevmode
\emph{array} --
extended maxima of the image

\end{description}\end{quote}

\end{fulllineitems}

\index{findExtendedMaxima() (in module ClearMap.ImageProcessing.MaximaDetection)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.ImageProcessing:ClearMap.ImageProcessing.MaximaDetection.findExtendedMaxima}\pysiglinewithargsret{\bfcode{findExtendedMaxima}}{\emph{img}, \emph{findExtendedMaximaParameter=None}, \emph{hMax=None}, \emph{size=5}, \emph{threshold=None}, \emph{save=None}, \emph{verbose=None}, \emph{subStack=None}, \emph{out=\textless{}open file `\textless{}stdout\textgreater{}'}, \emph{mode `w'\textgreater{}}, \emph{**parameter}}{}
Find extended maxima in an image

Effectively this routine performs a h-max transfrom, followed by a local maxima search and
thresholding of the maxima.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{img} (\emph{array}) --
image data

\item {} 
\textbf{findExtendedMaximaParameter} (\emph{dict}) --

\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textsf{\relax 
Name
} & \textsf{\relax 
Type
} & \textsf{\relax 
Descritption
}\\
\hline
\emph{hMax}
 & 
(float or None)
 & 
h parameter for the initial h-Max transform
if None, do not perform a h-max transform
\\
\hline
\emph{size}
 & 
(tuple)
 & 
size for the structure element for the local maxima filter
\\
\hline
\emph{threshold}
 & 
(float or None)
 & 
include only maxima larger than a threshold
if None keep all localmaxima
\\
\hline
\emph{save}
 & 
(str or None)
 & 
file name to save result of this operation
if None do not save result to file
\\
\hline
\emph{verbose}
 & 
(bool or int)
 & 
print / plot information about this step
\\
\hline\end{tabulary}


\item {} 
\textbf{subStack} (\emph{dict or None}) --
sub-stack information

\item {} 
\textbf{verbose} (\emph{bool}) --
print progress info

\item {} 
\textbf{out} (\emph{object}) --
object to write progress info to

\end{itemize}

\item[{Returns}] \leavevmode
\emph{array} --
binary image with True pixel at extended maxima

\end{description}\end{quote}


\strong{See also:}


{\hyperref[api/ClearMap.ImageProcessing:ClearMap.ImageProcessing.MaximaDetection.hMaxTransform]{\emph{\code{hMaxTransform()}}}}, {\hyperref[api/ClearMap.ImageProcessing:ClearMap.ImageProcessing.MaximaDetection.localMax]{\emph{\code{localMax()}}}}



\end{fulllineitems}

\index{findCenterOfMaxima() (in module ClearMap.ImageProcessing.MaximaDetection)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.ImageProcessing:ClearMap.ImageProcessing.MaximaDetection.findCenterOfMaxima}\pysiglinewithargsret{\bfcode{findCenterOfMaxima}}{\emph{img}, \emph{imgmax}, \emph{findCenterOfMaximaParameter=None}, \emph{save=None}, \emph{verbose=False}, \emph{subStack=None}, \emph{out=\textless{}open file `\textless{}stdout\textgreater{}'}, \emph{mode `w'\textgreater{}}, \emph{**parameter}}{}
Find center of detected maxima weighted by intensity
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{img} (\emph{array}) --
image data

\item {} 
\textbf{findCenterOfMaximaParameter} (\emph{dict}) --

\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textsf{\relax 
Name
} & \textsf{\relax 
Type
} & \textsf{\relax 
Descritption
}\\
\hline
\emph{save}
 & 
(str or None)
 & 
saves result of labeling the differnet maxima
if None, do the lableling is not saved
\\
\hline
\emph{verbose}
 & 
(bool or int)
 & 
print / plot information about this step
\\
\hline\end{tabulary}


\item {} 
\textbf{subStack} (\emph{dict or None}) --
sub-stack information

\item {} 
\textbf{verbose} (\emph{bool}) --
print progress info

\item {} 
\textbf{out} (\emph{object}) --
object to write progress info to

\end{itemize}

\item[{Returns}] \leavevmode

\emph{array} --
coordinates of centers of maxima, shape is (n,d) where n is
\begin{quote}

number of maxima and d the dimension of the image
\end{quote}


\end{description}\end{quote}

\end{fulllineitems}

\index{findPixelCoordinates() (in module ClearMap.ImageProcessing.MaximaDetection)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.ImageProcessing:ClearMap.ImageProcessing.MaximaDetection.findPixelCoordinates}\pysiglinewithargsret{\bfcode{findPixelCoordinates}}{\emph{imgmax}, \emph{subStack=None}, \emph{verbose=False}, \emph{out=\textless{}open file `\textless{}stdout\textgreater{}'}, \emph{mode `w'\textgreater{}}, \emph{**parameter}}{}
Find coordinates of all pixel in an image with positive or True value
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{img} (\emph{array}) --
image data

\item {} 
\textbf{verbose} (\emph{bool}) --
print progress info

\item {} 
\textbf{out} (\emph{object}) --
object to write progress info to

\end{itemize}

\item[{Returns}] \leavevmode

\emph{array} --
coordinates of centers of True pixels, shape is (n,d)  where n is
\begin{quote}

number of maxima and d the dimension of the image
\end{quote}


\end{description}\end{quote}

\end{fulllineitems}

\index{findIntensity() (in module ClearMap.ImageProcessing.MaximaDetection)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.ImageProcessing:ClearMap.ImageProcessing.MaximaDetection.findIntensity}\pysiglinewithargsret{\bfcode{findIntensity}}{\emph{img}, \emph{centers}, \emph{findIntensityParameter=None}, \emph{method=None}, \emph{size=(3}, \emph{3}, \emph{3)}, \emph{verbose=False}, \emph{out=\textless{}open file `\textless{}stdout\textgreater{}'}, \emph{mode `w'\textgreater{}}, \emph{**parameter}}{}
Find instensity value around centers in the image
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{img} (\emph{array}) --
image data

\item {} 
\textbf{findIntensityParameter} (\emph{dict}) --

\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textsf{\relax 
Name
} & \textsf{\relax 
Type
} & \textsf{\relax 
Descritption
}\\
\hline
\emph{method}
 & 
(str, func, None)
 & 
method to use to determine intensity (e.g. ``Max'' or ``Mean'')
if None take intensities at the given pixels
\\
\hline
\emph{size}
 & 
(tuple)
 & 
size of the box on which to perform the \emph{method}
\\
\hline
\emph{verbose}
 & 
(bool or int)
 & 
print / plot information about this step
\\
\hline\end{tabulary}


\item {} 
\textbf{verbose} (\emph{bool}) --
print progress info

\item {} 
\textbf{out} (\emph{object}) --
object to write progress info to

\end{itemize}

\item[{Returns}] \leavevmode
\emph{array} --
measured intensities

\end{description}\end{quote}

\end{fulllineitems}



\paragraph{ClearMap.ImageProcessing.IlastikClassification module}
\label{api/ClearMap.ImageProcessing:module-ClearMap.ImageProcessing.IlastikClassification}\label{api/ClearMap.ImageProcessing:clearmap-imageprocessing-ilastikclassification-module}\index{ClearMap.ImageProcessing.IlastikClassification (module)}
Inteface to Illastik pixel classification

This module allows to integrate ilastik pixel classification into the \emph{ClearMap}
pipeline.

To train a classifier ilastik 0.5 should be used following these steps:
\begin{itemize}
\item {} 
genereate a classifier from illastik 0.5

\item {} 
press `Train and classify' button (eventhough the online traning is running) !

\item {} 
save the classifier to a file

\item {} 
use the classifiers file name in the ClearMap routine {\hyperref[api/ClearMap.ImageProcessing:ClearMap.ImageProcessing.IlastikClassification.classifyPixel]{\emph{\code{classifyPixel()}}}}

\item {} 
try to avoid too many features in the classifier
as classification gets very memory intensive otherwise

\end{itemize}

\begin{notice}{note}{Note:}
Note that ilastik classification works in parallel, thus it is advised to
process the data sequentially, see
{\color{red}\bfseries{}:fun:{}`\textasciitilde{}ClearMap.Imageprocessing.StackProcessing.sequentiallyProcessStack{}`}
\end{notice}

\begin{notice}{note}{Note:}
Ilastik 0.5 works for images in uint8 format !
\end{notice}
\paragraph{References}
\begin{itemize}
\item {} 
\href{http://ilastik.org/}{Ilastik}

\item {} 
Based on the ilastik interface from \href{http://www.cellprofiler.org/}{cell profiler}

\end{itemize}
\index{initializeIlastik() (in module ClearMap.ImageProcessing.IlastikClassification)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.ImageProcessing:ClearMap.ImageProcessing.IlastikClassification.initializeIlastik}\pysiglinewithargsret{\bfcode{initializeIlastik}}{\emph{path=None}}{}
Set system path for illastik installation

\end{fulllineitems}

\index{Initialized (in module ClearMap.ImageProcessing.IlastikClassification)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.ImageProcessing:ClearMap.ImageProcessing.IlastikClassification.Initialized}\pysigline{\bfcode{Initialized}\strong{ = True}}
bool: True if ilastik interface was sucessfully initialized .

\end{fulllineitems}

\index{rescaleToIlastik() (in module ClearMap.ImageProcessing.IlastikClassification)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.ImageProcessing:ClearMap.ImageProcessing.IlastikClassification.rescaleToIlastik}\pysiglinewithargsret{\bfcode{rescaleToIlastik}}{\emph{img}, \emph{rescale=None}, \emph{verbose=False}, \emph{out=\textless{}open file `\textless{}stdout\textgreater{}'}, \emph{mode `w'\textgreater{}}, \emph{**parameter}}{}
Rescale image to achieve uint8 format used by ilasstik

The function rescales the image and converts the image to uin8
to fit with the image representation used by ilastik.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{img} (\emph{array}) --
image data

\item {} 
\textbf{rescale} (\emph{float or None}) --
rescaling factor

\end{itemize}

\item[{Returns}] \leavevmode
\emph{array} --
uint8 version of the image

\end{description}\end{quote}

\end{fulllineitems}

\index{rescaleFactorIlastik() (in module ClearMap.ImageProcessing.IlastikClassification)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.ImageProcessing:ClearMap.ImageProcessing.IlastikClassification.rescaleFactorIlastik}\pysiglinewithargsret{\bfcode{rescaleFactorIlastik}}{\emph{source}, \emph{processes=12}}{}
Determines rescale factor given a image file
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{source} --
source file / image

\item[{Returns}] \leavevmode
\emph{float} --
rescale factor

\end{description}\end{quote}

\end{fulllineitems}

\index{classifyPixel() (in module ClearMap.ImageProcessing.IlastikClassification)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.ImageProcessing:ClearMap.ImageProcessing.IlastikClassification.classifyPixel}\pysiglinewithargsret{\bfcode{classifyPixel}}{\emph{img}, \emph{classifyPixelParameter=None}, \emph{subStack=None}, \emph{verbose=False}, \emph{out=\textless{}open file `\textless{}stdout\textgreater{}'}, \emph{mode `w'\textgreater{}}, \emph{**parameter}}{}
Detect Cells Using a trained classifier in Ilastik
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{img} (\emph{array}) --
image data

\item {} 
\textbf{classifyPixelParameter} (\emph{dict}) --

\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textsf{\relax 
Name
} & \textsf{\relax 
Type
} & \textsf{\relax 
Descritption
}\\
\hline
\emph{classifier}
 & 
(str or  None)
 & 
saves result of labeling the differnet maxima
if None dont correct image for illumination, if True the
\\
\hline
\emph{rescale}
 & 
(float,all, or None)
 & 
optional rescaling of the image to fit uint8 format
used by ilastik,  rescale
\\
\hline
\emph{save}
 & 
(str or None)
 & 
save the propabilities to belong to the classes to a file
\\
\hline
\emph{verbose}
 & 
(bool or int)
 & 
print / plot information about this step
\\
\hline\end{tabulary}


\item {} 
\textbf{subStack} (\emph{dict or None}) --
sub-stack information

\item {} 
\textbf{verbose} (\emph{bool}) --
print progress info

\item {} 
\textbf{out} (\emph{object}) --
object to write progress info to

\end{itemize}

\item[{Returns}] \leavevmode

\emph{array} --
probabilities for each pixel to belong to a class in the
\begin{quote}

classifier, shape is (img.shape, number of classes)
\end{quote}


\end{description}\end{quote}

\end{fulllineitems}

\index{classifyCells() (in module ClearMap.ImageProcessing.IlastikClassification)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.ImageProcessing:ClearMap.ImageProcessing.IlastikClassification.classifyCells}\pysiglinewithargsret{\bfcode{classifyCells}}{\emph{img}, \emph{classifyCellsParameter=None}, \emph{classifier=None}, \emph{rescale=None}, \emph{save=None}, \emph{verbose=False}, \emph{subStack=None}, \emph{out=\textless{}open file `\textless{}stdout\textgreater{}'}, \emph{mode `w'\textgreater{}}, \emph{**parameter}}{}
Detect Cells Using a trained classifier in Ilastik

The routine assumes that the first class is identifying the cells.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{img} (\emph{array}) --
image data
classifyPixelParameter (dict):
\begin{quote}

\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textsf{\relax 
Name
} & \textsf{\relax 
Type
} & \textsf{\relax 
Descritption
}\\
\hline
\emph{classifier}
 & 
(str or  None)
 & 
saves result of labeling the differnet maxima
if None dont correct image for illumination, if True the
\\
\hline
\emph{rescale}
 & 
(float or None)
 & 
optional rescaling of the image to fit uint8 format
used by ilastik
\\
\hline
\emph{save}
 & 
(str or None)
 & 
save the detected cell pixel to a file
\\
\hline
\emph{verbose}
 & 
(bool or int)
 & 
print / plot information about this step
\\
\hline\end{tabulary}

\end{quote}

subStack (dict or None): sub-stack information
verbose (bool): print progress info
out (object): object to write progress info to

\item[{Returns}] \leavevmode
\emph{tuple} --
centers of the cells, intensity measurments

\end{description}\end{quote}

\begin{notice}{note}{Note:}
The routine could be poteNtially refined to make use of background
detected by ilastik
\end{notice}

\end{fulllineitems}



\paragraph{ClearMap.ImageProcessing.ImageStatistics module}
\label{api/ClearMap.ImageProcessing:clearmap-imageprocessing-imagestatistics-module}

\subsubsection{ClearMap.Analysis package}
\label{api/ClearMap.Analysis:clearmap-analysis-package}\label{api/ClearMap.Analysis::doc}\label{api/ClearMap.Analysis:module-ClearMap.Analysis}\index{ClearMap.Analysis (module)}
ClearMap analysis and statistics toolbox.

This part of ClearMap provides a toolbox for the statistical analysis and
visualization of detected cells or structures and region specific analysis
of annoated data.

For cleared mouse brains aligned to the Allen brain atlas a wide range of
statistical analysis tools with respect to the anotated brain regions in
the atlas is supported.

Key moduls are:

\begin{tabulary}{\linewidth}{|L|L|}
\hline
\textsf{\relax 
Module
} & \textsf{\relax 
Descrition
}\\
\hline
{\hyperref[api/ClearMap.Analysis:module-ClearMap.Analysis.Voxelization]{\emph{\code{Voxelization}}}}
 & 
Voxelization of cells for visualization and analysis
\\
\hline
{\hyperref[api/ClearMap.Analysis:module-ClearMap.Analysis.Statistics]{\emph{\code{Statistics}}}}
 & 
Statistical tools for the analysis of detected cells
\\
\hline
{\hyperref[api/ClearMap.Analysis:module-ClearMap.Analysis.Label]{\emph{\code{Label}}}}
 & 
Tools to analysise data with espect to annotated refereneces
\\
\hline\end{tabulary}



\paragraph{Subpackages}
\label{api/ClearMap.Analysis:subpackages}

\subparagraph{ClearMap.Analysis.Tools package}
\label{api/ClearMap.Analysis.Tools:clearmap-analysis-tools-package}\label{api/ClearMap.Analysis.Tools:module-ClearMap.Analysis.Tools}\label{api/ClearMap.Analysis.Tools::doc}\index{ClearMap.Analysis.Tools (module)}
Analysis and statistics tools not in standard python packages.


\subparagraph{ClearMap.Analysis.Tools.Extrapolate module}
\label{api/ClearMap.Analysis.Tools:clearmap-analysis-tools-extrapolate-module}\label{api/ClearMap.Analysis.Tools:module-ClearMap.Analysis.Tools.Extrapolate}\index{ClearMap.Analysis.Tools.Extrapolate (module)}
Method to extend interpolation objects to constantly / linearly extrapolate.
\index{extrap1d() (in module ClearMap.Analysis.Tools.Extrapolate)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.Analysis.Tools:ClearMap.Analysis.Tools.Extrapolate.extrap1d}\pysiglinewithargsret{\bfcode{extrap1d}}{\emph{x}, \emph{y}, \emph{interpolation='linear'}, \emph{exterpolation='constant'}}{}
Interpolate on given values and extrapolate outside the given data
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{x} (\emph{numpy.array}) --
x values of the data to interpolate

\item {} 
\textbf{y} (\emph{numpy.array}) --
y values of the data to interpolate

\item {} 
\textbf{interpolation} (\emph{Optional{[}str{]}}) --
interpolation method, see kind of scipy.interpolate.interp1d, default: ``linear''

\item {} 
\textbf{exterpolation} (\emph{Optional{[}str{]}}) --
interpolation method, either ``linear'' or ``constant''

\end{itemize}

\item[{Returns}] \leavevmode
\emph{(function)} --
inter- and extra-polation function

\end{description}\end{quote}

\end{fulllineitems}

\index{extrap1dFromInterp1d() (in module ClearMap.Analysis.Tools.Extrapolate)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.Analysis.Tools:ClearMap.Analysis.Tools.Extrapolate.extrap1dFromInterp1d}\pysiglinewithargsret{\bfcode{extrap1dFromInterp1d}}{\emph{interpolator}, \emph{exterpolation='constant'}}{}
Extend interpolation function to extrapolate outside the given data
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{interpolator} (\emph{function}) --
interpolating function, see e.g. scipy.interpolate.interp1d

\item {} 
\textbf{exterpolation} (\emph{Optional{[}str{]}}) --
interpolation method, either ``linear'' or ``constant''

\end{itemize}

\item[{Returns}] \leavevmode
\emph{(function)} --
inter- and extra-polation function

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{ClearMap.Analysis.Tools.MultipleComparisonCorrection module}
\label{api/ClearMap.Analysis.Tools:clearmap-analysis-tools-multiplecomparisoncorrection-module}\label{api/ClearMap.Analysis.Tools:module-ClearMap.Analysis.Tools.MultipleComparisonCorrection}\index{ClearMap.Analysis.Tools.MultipleComparisonCorrection (module)}
Correction methods for multiple comparison tests
\index{correctPValues() (in module ClearMap.Analysis.Tools.MultipleComparisonCorrection)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.Analysis.Tools:ClearMap.Analysis.Tools.MultipleComparisonCorrection.correctPValues}\pysiglinewithargsret{\bfcode{correctPValues}}{\emph{pvalues}, \emph{method='BH'}}{}
Corrects p-values for multiple testing using various methods
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{pvalues} (\emph{array}) --
list of p values to be corrected

\item {} 
\textbf{method} (\emph{Optional{[}str{]}}) --
method to use: BH = FDR = Benjamini-Hochberg, B = FWER = Bonferoni

\end{itemize}

\end{description}\end{quote}
\paragraph{References}
\begin{itemize}
\item {} 
\href{http://www.jstor.org/stable/2346101?seq=1\#page\_scan\_tab\_contents}{Benjamini Hochberg, 1995}

\item {} 
\href{http://www.tandfonline.com/doi/abs/10.1080/01621459.1961.10482090\#.VmHWUHbH6KE}{Bonferoni correction}

\item {} 
\href{https://www.r-project.org/}{R statistics package}

\end{itemize}
\paragraph{Notes}
\begin{itemize}
\item {} 
modified from \href{http://statsmodels.sourceforge.net/ipdirective/generated/scikits.statsmodels.sandbox.stats.multicomp.multipletests.html}{http://statsmodels.sourceforge.net/ipdirective/generated/scikits.statsmodels.sandbox.stats.multicomp.multipletests.html}

\end{itemize}

\end{fulllineitems}

\index{estimateQValues() (in module ClearMap.Analysis.Tools.MultipleComparisonCorrection)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.Analysis.Tools:ClearMap.Analysis.Tools.MultipleComparisonCorrection.estimateQValues}\pysiglinewithargsret{\bfcode{estimateQValues}}{\emph{pvalues}, \emph{m=None}, \emph{pi0=None}, \emph{verbose=False}, \emph{lowMemory=False}}{}
Estimates q-values from p-values
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{pvalues} (\emph{array}) --
list of p-values

\item {} 
\textbf{m} (\emph{int or None}) --
number of tests. If None, m = pvalues.size

\item {} 
\textbf{pi0} (\emph{float or None}) --
estimate of m\_0 / m which is the (true null / total tests) ratio, if None estimation via cubic spline.

\item {} 
\textbf{verbose} (\emph{bool}) --
print info during execution

\item {} 
\textbf{lowMemory} (\emph{bool}) --
if true use low memory version

\end{itemize}

\end{description}\end{quote}
\paragraph{Notes}
\begin{itemize}
\item {} 
The q-value of a particular feature can be described as the expected proportion of
false  positives  among  all  features  as  or  more  extreme  than  the observed one

\item {} 
The estimated q-values are increasing in the same order as the p-values

\end{itemize}
\paragraph{References}
\begin{itemize}
\item {} 
\href{http://www.pnas.org/content/100/16/9440.full}{Storey and Tibshirani, 2003}

\item {} 
modified from \href{https://github.com/nfusi/qvalue}{https://github.com/nfusi/qvalue}

\end{itemize}

\end{fulllineitems}



\subparagraph{ClearMap.Analysis.Tools.StatisticalTests module}
\label{api/ClearMap.Analysis.Tools:module-ClearMap.Analysis.Tools.StatisticalTests}\label{api/ClearMap.Analysis.Tools:clearmap-analysis-tools-statisticaltests-module}\index{ClearMap.Analysis.Tools.StatisticalTests (module)}
Some statistics tests not in standard python packages
\index{testCramerVonMises2Sample() (in module ClearMap.Analysis.Tools.StatisticalTests)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.Analysis.Tools:ClearMap.Analysis.Tools.StatisticalTests.testCramerVonMises2Sample}\pysiglinewithargsret{\bfcode{testCramerVonMises2Sample}}{\emph{x}, \emph{y}}{}
Computes the Cramer von Mises two sample test.

This is a two-sided test for the null hypothesis that 2 independent samples
are drawn from the same continuous distribution.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{x, y} (\emph{sequence of 1-D ndarrays}) --
two arrays of sample observations

\item {} 
\textbf{assumed to be drawn from a continuous distribution, sample sizes}

\item {} 
\textbf{can be different}

\end{itemize}

\item[{Returns}] \leavevmode
\emph{(float, float)} --
T statistic, two-tailed p-value

\end{description}\end{quote}
\paragraph{References}
\begin{itemize}
\item {} 
modified from \href{https://github.com/scipy/scipy/pull/3659}{https://github.com/scipy/scipy/pull/3659}

\end{itemize}

\end{fulllineitems}



\paragraph{ClearMap.Analysis.Label module}
\label{api/ClearMap.Analysis:module-ClearMap.Analysis.Label}\label{api/ClearMap.Analysis:clearmap-analysis-label-module}\index{ClearMap.Analysis.Label (module)}
Label and annotation info from Allen Brain Atlas (v2)
\paragraph{Notes}
\begin{itemize}
\item {} 
The annotation file is assumed to be in `./Data/Annotation/annotation\_25\_right.tif'
but can be set in the constant {\hyperref[api/ClearMap.Analysis:ClearMap.Analysis.Label.DefaultLabeledImageFile]{\emph{\code{DefaultLabeledImageFile}}}}

\item {} 
The mapping between labels and brain area information is found in the
`./Data/ARA2\_annotation\_info.csv' file.
In the `./Data/ARA2\_annotation\_info\_collapse.csv' file a cross marks an area
to which all sub-areas will be collapsed.
The location of this file is set in {\hyperref[api/ClearMap.Analysis:ClearMap.Analysis.Label.DefaultAnnotationFile]{\emph{\code{DefaultAnnotationFile}}}}.

\item {} 
For consistentcy cretain labels of the Allen brain atlas without
annotation were assinged to their correct parent regions.

\item {} 
A collapse collumn in the mapping file was added to allow for a region
based collapse of statistics based on the inheritance structure of the
annotated regions. These might need to be adjusted to the particular
scientific question.

\end{itemize}
\paragraph{References}
\begin{itemize}
\item {} 
\href{http://mouse.brain-map.org/static/atlas}{Allen Brain Atlas}

\end{itemize}
\index{DefaultLabeledImageFile (in module ClearMap.Analysis.Label)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.Analysis:ClearMap.Analysis.Label.DefaultLabeledImageFile}\pysigline{\bfcode{DefaultLabeledImageFile}\strong{ = `/home/ckirst/Science/Projects/BrainActivityMap/Analysis/ClearMap/Test/Data/Annotation/annotation\_25\_right.tif'}}
str: default volumetric annotated image file

This file is by default the Allen brain annotated mouse atlas with 25um
isotropic reslution.

\end{fulllineitems}

\index{DefaultAnnotationFile (in module ClearMap.Analysis.Label)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.Analysis:ClearMap.Analysis.Label.DefaultAnnotationFile}\pysigline{\bfcode{DefaultAnnotationFile}\strong{ = `/home/ckirst/Science/Projects/BrainActivityMap/Analysis/ClearMap/Data/ARA2\_annotation\_info\_collapse.csv'}}
str: default list of labels in the annotatd image and names of annotated regoins

This file is by default the lables for the Allen brain annotated mouse
atlas with 25um isotropic reslution.

An extra column for collapse indicats how to automatically collapse data into
the different bain regions if the \code{collapse} option is given.

\end{fulllineitems}

\index{LabelRecord (class in ClearMap.Analysis.Label)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.Analysis:ClearMap.Analysis.Label.LabelRecord}\pysiglinewithargsret{\strong{class }\bfcode{LabelRecord}}{\emph{id}, \emph{name}, \emph{acronym}, \emph{color}, \emph{parent}, \emph{collapse}}{}
Bases: \code{tuple}

Structure of a label for a annotated region
\index{\_\_getnewargs\_\_() (LabelRecord method)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.Analysis:ClearMap.Analysis.Label.LabelRecord.__getnewargs__}\pysiglinewithargsret{\bfcode{\_\_getnewargs\_\_}}{}{}
Return self as a plain tuple.  Used by copy and pickle.

\end{fulllineitems}

\index{\_\_getstate\_\_() (LabelRecord method)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.Analysis:ClearMap.Analysis.Label.LabelRecord.__getstate__}\pysiglinewithargsret{\bfcode{\_\_getstate\_\_}}{}{}
Exclude the OrderedDict from pickling

\end{fulllineitems}

\index{\_\_repr\_\_() (LabelRecord method)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.Analysis:ClearMap.Analysis.Label.LabelRecord.__repr__}\pysiglinewithargsret{\bfcode{\_\_repr\_\_}}{}{}
Return a nicely formatted representation string

\end{fulllineitems}

\index{acronym (LabelRecord attribute)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.Analysis:ClearMap.Analysis.Label.LabelRecord.acronym}\pysigline{\bfcode{acronym}}
Alias for field number 2

\end{fulllineitems}

\index{collapse (LabelRecord attribute)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.Analysis:ClearMap.Analysis.Label.LabelRecord.collapse}\pysigline{\bfcode{collapse}}
Alias for field number 5

\end{fulllineitems}

\index{color (LabelRecord attribute)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.Analysis:ClearMap.Analysis.Label.LabelRecord.color}\pysigline{\bfcode{color}}
Alias for field number 3

\end{fulllineitems}

\index{id (LabelRecord attribute)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.Analysis:ClearMap.Analysis.Label.LabelRecord.id}\pysigline{\bfcode{id}}
Alias for field number 0

\end{fulllineitems}

\index{name (LabelRecord attribute)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.Analysis:ClearMap.Analysis.Label.LabelRecord.name}\pysigline{\bfcode{name}}
Alias for field number 1

\end{fulllineitems}

\index{parent (LabelRecord attribute)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.Analysis:ClearMap.Analysis.Label.LabelRecord.parent}\pysigline{\bfcode{parent}}
Alias for field number 4

\end{fulllineitems}


\end{fulllineitems}

\index{LabelInfo (class in ClearMap.Analysis.Label)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.Analysis:ClearMap.Analysis.Label.LabelInfo}\pysiglinewithargsret{\strong{class }\bfcode{LabelInfo}}{\emph{slf}, \emph{annotationFile='/home/ckirst/Science/Projects/BrainActivityMap/Analysis/ClearMap/Data/ARA2\_annotation\_info\_collapse.csv'}}{}
Bases: \code{object}

Class that holds infomration of the annotated regions
\index{ids (LabelInfo attribute)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.Analysis:ClearMap.Analysis.Label.LabelInfo.ids}\pysigline{\bfcode{ids}\strong{ = None}}
\end{fulllineitems}

\index{names (LabelInfo attribute)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.Analysis:ClearMap.Analysis.Label.LabelInfo.names}\pysigline{\bfcode{names}\strong{ = None}}
\end{fulllineitems}

\index{acronyms (LabelInfo attribute)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.Analysis:ClearMap.Analysis.Label.LabelInfo.acronyms}\pysigline{\bfcode{acronyms}\strong{ = None}}
\end{fulllineitems}

\index{colors (LabelInfo attribute)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.Analysis:ClearMap.Analysis.Label.LabelInfo.colors}\pysigline{\bfcode{colors}\strong{ = None}}
\end{fulllineitems}

\index{parents (LabelInfo attribute)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.Analysis:ClearMap.Analysis.Label.LabelInfo.parents}\pysigline{\bfcode{parents}\strong{ = None}}
\end{fulllineitems}

\index{levels (LabelInfo attribute)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.Analysis:ClearMap.Analysis.Label.LabelInfo.levels}\pysigline{\bfcode{levels}\strong{ = None}}
\end{fulllineitems}

\index{collapse (LabelInfo attribute)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.Analysis:ClearMap.Analysis.Label.LabelInfo.collapse}\pysigline{\bfcode{collapse}\strong{ = None}}
\end{fulllineitems}

\index{collapseMap (LabelInfo attribute)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.Analysis:ClearMap.Analysis.Label.LabelInfo.collapseMap}\pysigline{\bfcode{collapseMap}\strong{ = None}}
\end{fulllineitems}

\index{initialize() (LabelInfo method)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.Analysis:ClearMap.Analysis.Label.LabelInfo.initialize}\pysiglinewithargsret{\bfcode{initialize}}{\emph{slf}, \emph{annotationFile='/home/ckirst/Science/Projects/BrainActivityMap/Analysis/ClearMap/Data/ARA2\_annotation\_info\_collapse.csv'}}{}
\end{fulllineitems}

\index{name() (LabelInfo method)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.Analysis:ClearMap.Analysis.Label.LabelInfo.name}\pysiglinewithargsret{\bfcode{name}}{\emph{slf}, \emph{iid}}{}
\end{fulllineitems}

\index{acronym() (LabelInfo method)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.Analysis:ClearMap.Analysis.Label.LabelInfo.acronym}\pysiglinewithargsret{\bfcode{acronym}}{\emph{slf}, \emph{iid}}{}
\end{fulllineitems}

\index{color() (LabelInfo method)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.Analysis:ClearMap.Analysis.Label.LabelInfo.color}\pysiglinewithargsret{\bfcode{color}}{\emph{slf}, \emph{iid}}{}
\end{fulllineitems}

\index{parent() (LabelInfo method)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.Analysis:ClearMap.Analysis.Label.LabelInfo.parent}\pysiglinewithargsret{\bfcode{parent}}{\emph{slf}, \emph{iid}}{}
\end{fulllineitems}

\index{level() (LabelInfo method)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.Analysis:ClearMap.Analysis.Label.LabelInfo.level}\pysiglinewithargsret{\bfcode{level}}{\emph{slf}, \emph{iid}}{}
\end{fulllineitems}

\index{toLabelAtLevel() (LabelInfo method)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.Analysis:ClearMap.Analysis.Label.LabelInfo.toLabelAtLevel}\pysiglinewithargsret{\bfcode{toLabelAtLevel}}{\emph{slf}, \emph{iid}, \emph{level}}{}
\end{fulllineitems}

\index{toLabelAtCollapseMap() (LabelInfo method)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.Analysis:ClearMap.Analysis.Label.LabelInfo.toLabelAtCollapseMap}\pysiglinewithargsret{\bfcode{toLabelAtCollapseMap}}{\emph{slf}, \emph{iid}}{}
\end{fulllineitems}

\index{toLabelAtCollapse() (LabelInfo method)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.Analysis:ClearMap.Analysis.Label.LabelInfo.toLabelAtCollapse}\pysiglinewithargsret{\bfcode{toLabelAtCollapse}}{\emph{slf}, \emph{iid}}{}
\end{fulllineitems}


\end{fulllineitems}

\index{Label (in module ClearMap.Analysis.Label)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.Analysis:ClearMap.Analysis.Label.Label}\pysigline{\bfcode{Label}\strong{ = \textless{}ClearMap.Analysis.Label.LabelInfo object\textgreater{}}}
Information on the annotated regions

\end{fulllineitems}

\index{initialize() (in module ClearMap.Analysis.Label)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.Analysis:ClearMap.Analysis.Label.initialize}\pysiglinewithargsret{\bfcode{initialize}}{\emph{annotationFile='/home/ckirst/Science/Projects/BrainActivityMap/Analysis/ClearMap/Data/ARA2\_annotation\_info\_collapse.csv'}}{}
\end{fulllineitems}

\index{labelAtLevel() (in module ClearMap.Analysis.Label)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.Analysis:ClearMap.Analysis.Label.labelAtLevel}\pysiglinewithargsret{\bfcode{labelAtLevel}}{\emph{label}, \emph{level}}{}
\end{fulllineitems}

\index{labelAtCollapse() (in module ClearMap.Analysis.Label)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.Analysis:ClearMap.Analysis.Label.labelAtCollapse}\pysiglinewithargsret{\bfcode{labelAtCollapse}}{\emph{label}}{}
\end{fulllineitems}

\index{labelPoints() (in module ClearMap.Analysis.Label)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.Analysis:ClearMap.Analysis.Label.labelPoints}\pysiglinewithargsret{\bfcode{labelPoints}}{\emph{points}, \emph{labeledImage='/home/ckirst/Science/Projects/BrainActivityMap/Analysis/ClearMap/Test/Data/Annotation/annotation\_25\_right.tif'}, \emph{level=None}, \emph{collapse=None}}{}
\end{fulllineitems}

\index{countPointsInRegions() (in module ClearMap.Analysis.Label)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.Analysis:ClearMap.Analysis.Label.countPointsInRegions}\pysiglinewithargsret{\bfcode{countPointsInRegions}}{\emph{points}, \emph{labeledImage='/home/ckirst/Science/Projects/BrainActivityMap/Analysis/ClearMap/Test/Data/Annotation/annotation\_25\_right.tif'}, \emph{intensities=None}, \emph{intensityRow=0}, \emph{level=None}, \emph{allIds=False}, \emph{sort=True}, \emph{returnIds=True}, \emph{returnCounts=False}, \emph{collapse=None}}{}
\end{fulllineitems}

\index{labelToName() (in module ClearMap.Analysis.Label)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.Analysis:ClearMap.Analysis.Label.labelToName}\pysiglinewithargsret{\bfcode{labelToName}}{\emph{label}}{}
\end{fulllineitems}

\index{labelToAcronym() (in module ClearMap.Analysis.Label)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.Analysis:ClearMap.Analysis.Label.labelToAcronym}\pysiglinewithargsret{\bfcode{labelToAcronym}}{\emph{label}}{}
\end{fulllineitems}

\index{labelToColor() (in module ClearMap.Analysis.Label)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.Analysis:ClearMap.Analysis.Label.labelToColor}\pysiglinewithargsret{\bfcode{labelToColor}}{\emph{label}}{}
\end{fulllineitems}

\index{writePAL() (in module ClearMap.Analysis.Label)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.Analysis:ClearMap.Analysis.Label.writePAL}\pysiglinewithargsret{\bfcode{writePAL}}{\emph{filename}, \emph{cols}}{}
\end{fulllineitems}

\index{writeLUT() (in module ClearMap.Analysis.Label)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.Analysis:ClearMap.Analysis.Label.writeLUT}\pysiglinewithargsret{\bfcode{writeLUT}}{\emph{filename}, \emph{cols}}{}
\end{fulllineitems}

\index{makeColorPalette() (in module ClearMap.Analysis.Label)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.Analysis:ClearMap.Analysis.Label.makeColorPalette}\pysiglinewithargsret{\bfcode{makeColorPalette}}{\emph{filename=None}}{}
Creates a pal file for imaris based on label colors

\end{fulllineitems}

\index{makeColorAnnotations() (in module ClearMap.Analysis.Label)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.Analysis:ClearMap.Analysis.Label.makeColorAnnotations}\pysiglinewithargsret{\bfcode{makeColorAnnotations}}{\emph{filename}, \emph{labeledImage=None}}{}
\end{fulllineitems}

\index{test() (in module ClearMap.Analysis.Label)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.Analysis:ClearMap.Analysis.Label.test}\pysiglinewithargsret{\bfcode{test}}{}{}
Test Label module

\end{fulllineitems}



\paragraph{ClearMap.Analysis.Statistics module}
\label{api/ClearMap.Analysis:clearmap-analysis-statistics-module}\label{api/ClearMap.Analysis:module-ClearMap.Analysis.Statistics}\index{ClearMap.Analysis.Statistics (module)}
Create some statistics to test significant changes
in voxelized and labeled data

TODO: cleanup / make generic
\index{readDataGroup() (in module ClearMap.Analysis.Statistics)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.Analysis:ClearMap.Analysis.Statistics.readDataGroup}\pysiglinewithargsret{\bfcode{readDataGroup}}{\emph{filenames}, \emph{combine=True}, \emph{**args}}{}
Turn a list of filenames for data into a numpy stack

\end{fulllineitems}

\index{readPointsGroup() (in module ClearMap.Analysis.Statistics)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.Analysis:ClearMap.Analysis.Statistics.readPointsGroup}\pysiglinewithargsret{\bfcode{readPointsGroup}}{\emph{filenames}, \emph{**args}}{}
Turn a list of filenames for points into a numpy stack

\end{fulllineitems}

\index{tTestVoxelization() (in module ClearMap.Analysis.Statistics)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.Analysis:ClearMap.Analysis.Statistics.tTestVoxelization}\pysiglinewithargsret{\bfcode{tTestVoxelization}}{\emph{group1}, \emph{group2}, \emph{signed=False}, \emph{removeNaN=True}, \emph{pcutoff=None}}{}
t-Test on differences between the individual voxels in group1 and group2, group is a array of voxelizations

\end{fulllineitems}

\index{cutoffPValues() (in module ClearMap.Analysis.Statistics)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.Analysis:ClearMap.Analysis.Statistics.cutoffPValues}\pysiglinewithargsret{\bfcode{cutoffPValues}}{\emph{pvals}, \emph{pcutoff=0.05}}{}
\end{fulllineitems}

\index{colorPValues() (in module ClearMap.Analysis.Statistics)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.Analysis:ClearMap.Analysis.Statistics.colorPValues}\pysiglinewithargsret{\bfcode{colorPValues}}{\emph{pvals, psign, positive={[}1, 0{]}, negative={[}0, 1{]}, pcutoff=None, positivetrend={[}0, 0, 1, 0{]}, negativetrend={[}0, 0, 0, 1{]}, pmax=None}}{}
\end{fulllineitems}

\index{mean() (in module ClearMap.Analysis.Statistics)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.Analysis:ClearMap.Analysis.Statistics.mean}\pysiglinewithargsret{\bfcode{mean}}{\emph{group}, \emph{**args}}{}
\end{fulllineitems}

\index{std() (in module ClearMap.Analysis.Statistics)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.Analysis:ClearMap.Analysis.Statistics.std}\pysiglinewithargsret{\bfcode{std}}{\emph{group}, \emph{**args}}{}
\end{fulllineitems}

\index{var() (in module ClearMap.Analysis.Statistics)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.Analysis:ClearMap.Analysis.Statistics.var}\pysiglinewithargsret{\bfcode{var}}{\emph{group}, \emph{**args}}{}
\end{fulllineitems}

\index{thresholdPoints() (in module ClearMap.Analysis.Statistics)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.Analysis:ClearMap.Analysis.Statistics.thresholdPoints}\pysiglinewithargsret{\bfcode{thresholdPoints}}{\emph{points}, \emph{intensities}, \emph{threshold=0}, \emph{row=0}}{}
Threshold points by intensities

\end{fulllineitems}

\index{weightsFromPrecentiles() (in module ClearMap.Analysis.Statistics)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.Analysis:ClearMap.Analysis.Statistics.weightsFromPrecentiles}\pysiglinewithargsret{\bfcode{weightsFromPrecentiles}}{\emph{intensities, percentiles={[}25, 50, 75, 100{]}}}{}
\end{fulllineitems}

\index{countPointsGroupInRegions() (in module ClearMap.Analysis.Statistics)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.Analysis:ClearMap.Analysis.Statistics.countPointsGroupInRegions}\pysiglinewithargsret{\bfcode{countPointsGroupInRegions}}{\emph{pointGroup}, \emph{labeledImage='/home/ckirst/Science/Projects/BrainActivityMap/Analysis/ClearMap/Test/Data/Annotation/annotation\_25\_right.tif'}, \emph{intensityGroup=None}, \emph{intensityRow=0}, \emph{returnIds=True}, \emph{returnCounts=False}, \emph{collapse=None}}{}
Generates a table of counts for the various point datasets in pointGroup

\end{fulllineitems}

\index{tTestPointsInRegions() (in module ClearMap.Analysis.Statistics)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.Analysis:ClearMap.Analysis.Statistics.tTestPointsInRegions}\pysiglinewithargsret{\bfcode{tTestPointsInRegions}}{\emph{pointCounts1}, \emph{pointCounts2}, \emph{labeledImage='/home/ckirst/Science/Projects/BrainActivityMap/Analysis/ClearMap/Test/Data/Annotation/annotation\_25\_right.tif'}, \emph{signed=False}, \emph{removeNaN=True}, \emph{pcutoff=None}, \emph{equal\_var=False}}{}
t-Test on differences in counts of points in labeled regions

\end{fulllineitems}

\index{testCompletedCumulatives() (in module ClearMap.Analysis.Statistics)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.Analysis:ClearMap.Analysis.Statistics.testCompletedCumulatives}\pysiglinewithargsret{\bfcode{testCompletedCumulatives}}{\emph{data}, \emph{method='AndersonDarling'}, \emph{offset=None}, \emph{plot=False}}{}
Test if data sets have the same number / intensity distribution by adding max intensity counts to the smaller sized data sets and performing a distribution comparison test

\end{fulllineitems}

\index{testCompletedInvertedCumulatives() (in module ClearMap.Analysis.Statistics)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.Analysis:ClearMap.Analysis.Statistics.testCompletedInvertedCumulatives}\pysiglinewithargsret{\bfcode{testCompletedInvertedCumulatives}}{\emph{data}, \emph{method='AndersonDarling'}, \emph{offset=None}, \emph{plot=False}}{}
Test if data sets have the same number / intensity distribution by adding zero intensity counts to the smaller sized data sets and performing a distribution comparison test on the reversed cumulative distribution

\end{fulllineitems}

\index{testCompletedCumulativesInSpheres() (in module ClearMap.Analysis.Statistics)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.Analysis:ClearMap.Analysis.Statistics.testCompletedCumulativesInSpheres}\pysiglinewithargsret{\bfcode{testCompletedCumulativesInSpheres}}{\emph{points1}, \emph{intensities1}, \emph{points2}, \emph{intensities2}, \emph{dataSize='/home/ckirst/Science/Projects/BrainActivityMap/Analysis/ClearMap/Test/Data/Annotation/annotation\_25\_right.tif'}, \emph{radius=100}, \emph{method='AndresonDarling'}}{}
Performs completed cumulative distribution tests for each pixel using points in a ball centered at that cooridnates, returns 4 arrays p value, statistic value, number in each group

\end{fulllineitems}

\index{test() (in module ClearMap.Analysis.Statistics)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.Analysis:ClearMap.Analysis.Statistics.test}\pysiglinewithargsret{\bfcode{test}}{}{}
Test the statistics array

\end{fulllineitems}



\paragraph{ClearMap.Analysis.Voxelization module}
\label{api/ClearMap.Analysis:clearmap-analysis-voxelization-module}\label{api/ClearMap.Analysis:module-ClearMap.Analysis.Voxelization}\index{ClearMap.Analysis.Voxelization (module)}
Converts point data into voxel image data for visulaization and analysis
\index{voxelize() (in module ClearMap.Analysis.Voxelization)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.Analysis:ClearMap.Analysis.Voxelization.voxelize}\pysiglinewithargsret{\bfcode{voxelize}}{\emph{points}, \emph{dataSize=None}, \emph{sink=None}, \emph{voxelizeParameter=None}, \emph{method='Spherical'}, \emph{size=(5}, \emph{5}, \emph{5)}, \emph{weights=None}}{}
Converts a list of points into an volumetric image array
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{points} (\emph{array}) --
point data array

\item {} 
\textbf{dataSize} (\emph{tuple}) --
size of final image

\item {} 
\textbf{sink} (\emph{str, array or None}) --
the location to write or return the resulting voxelization image, if None return array

\item {} 
\textbf{voxelizeParameter} (\emph{dict}) --

\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textsf{\relax 
Name
} & \textsf{\relax 
Type
} & \textsf{\relax 
Descritption
}\\
\hline
\emph{method}
 & 
(str or None)
 & 
method for voxelization: `Spherical', `Rectangular' or `Pixel'
\\
\hline
\emph{size}
 & 
(tuple)
 & 
size parameter for the voxelization
\\
\hline
\emph{weights}
 & 
(array or None)
 & 
weights for each point, None is uniform weights
\\
\hline\end{tabulary}


\end{itemize}

\item[{Returns}] \leavevmode
\emph{(array)} --
volumetric data of smeared out points

\end{description}\end{quote}

\end{fulllineitems}

\index{voxelizePixel() (in module ClearMap.Analysis.Voxelization)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.Analysis:ClearMap.Analysis.Voxelization.voxelizePixel}\pysiglinewithargsret{\bfcode{voxelizePixel}}{\emph{points}, \emph{dataSize=None}, \emph{weights=None}}{}
Mark pixels/voxels of each point in an image array
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{points} (\emph{array}) --
point data array

\item {} 
\textbf{dataSize} (\emph{tuple or None}) --
size of the final output data, if None size is determined by maximal point coordinates

\item {} 
\textbf{weights} (\emph{array or None}) --
weights for each points, if None weights are all 1s.

\end{itemize}

\item[{Returns}] \leavevmode
\emph{(array)} --
volumetric data with with points marked in voxels

\end{description}\end{quote}

\end{fulllineitems}

\index{test() (in module ClearMap.Analysis.Voxelization)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.Analysis:ClearMap.Analysis.Voxelization.test}\pysiglinewithargsret{\bfcode{test}}{}{}
Test voxelization module

\end{fulllineitems}



\subsubsection{ClearMap.Visualization package}
\label{api/ClearMap.Visualization:module-ClearMap.Visualization}\label{api/ClearMap.Visualization::doc}\label{api/ClearMap.Visualization:clearmap-visualization-package}\index{ClearMap.Visualization (module)}
This sub-package provides tools for the visualization of the alignment and
analysis results

Author
\begin{quote}

Christoph Kirst, The Rockefeller University, New York City, 2015
\end{quote}


\paragraph{ClearMap.Visualization.Plot module}
\label{api/ClearMap.Visualization:module-ClearMap.Visualization.Plot}\label{api/ClearMap.Visualization:clearmap-visualization-plot-module}\index{ClearMap.Visualization.Plot (module)}
Plotting routines for overlaying lables, tilings, and sectioning of 3d data sets

Supported functionality:
\begin{itemize}
\item {} 
plot volumetric data as a sequnece of tiles via {\hyperref[api/ClearMap.Visualization:ClearMap.Visualization.Plot.plotTiling]{\emph{\code{plotTiling()}}}}

\item {} 
overlay points on imags via {\hyperref[api/ClearMap.Visualization:ClearMap.Visualization.Plot.overlayPoints]{\emph{\code{overlayPoints()}}}} and
{\hyperref[api/ClearMap.Visualization:ClearMap.Visualization.Plot.plotOverlayPoints]{\emph{\code{plotOverlayPoints()}}}}

\item {} 
overlay labeled images on gray scale images via {\hyperref[api/ClearMap.Visualization:ClearMap.Visualization.Plot.overlayLabel]{\emph{\code{overlayLabel()}}}} and
{\hyperref[api/ClearMap.Visualization:ClearMap.Visualization.Plot.plotOverlayLabel]{\emph{\code{plotOverlayLabel()}}}}

\end{itemize}

Author
\begin{quote}

Christoph Kirst, The Rockefeller University, 2015
\end{quote}
\index{plotTiling() (in module ClearMap.Visualization.Plot)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.Visualization:ClearMap.Visualization.Plot.plotTiling}\pysiglinewithargsret{\bfcode{plotTiling}}{\emph{dataSource}, \emph{tiling='automatic'}, \emph{maxtiles=20}, \emph{x=\textless{}built-in function all\textgreater{}}, \emph{y=\textless{}built-in function all\textgreater{}}, \emph{z=\textless{}built-in function all\textgreater{}}}{}
Plot 3d image as 2d tiles
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{dataSouce} (\emph{str or array}) --
volumetric image data

\item {} 
\textbf{tiling} (\emph{str or tuple}) --
tiling specification

\item {} 
\textbf{maxtiles} --
maximalnumber of tiles

\item {} 
\textbf{x, y, z} (\emph{all or tuple}) --
sub-range specification

\end{itemize}

\item[{Returns}] \leavevmode
\emph{(object)} --
figure handle

\end{description}\end{quote}

\end{fulllineitems}

\index{overlayLabel() (in module ClearMap.Visualization.Plot)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.Visualization:ClearMap.Visualization.Plot.overlayLabel}\pysiglinewithargsret{\bfcode{overlayLabel}}{\emph{dataSource}, \emph{labelSource}, \emph{sink=None}, \emph{alpha=False}, \emph{labelColorMap='jet'}, \emph{x=\textless{}built-in function all\textgreater{}}, \emph{y=\textless{}built-in function all\textgreater{}}, \emph{z=\textless{}built-in function all\textgreater{}}}{}
Overlay a gray scale image with colored labeled image
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{dataSouce} (\emph{str or array}) --
volumetric image data

\item {} 
\textbf{labelSource} (\emph{str or array}) --
labeled image to be overlayed on the image data

\item {} 
\textbf{sink} (\emph{str or None}) --
destination for the overlayed image

\item {} 
\textbf{alpha} (\emph{float or False}) --
transparency

\item {} 
\textbf{labelColorMap} (\emph{str or object}) --
color map for the labels

\item {} 
\textbf{x, y, z} (\emph{all or tuple}) --
sub-range specification

\end{itemize}

\item[{Returns}] \leavevmode
\emph{(array or str)} --
figure handle

\end{description}\end{quote}


\strong{See also:}


{\hyperref[api/ClearMap.Visualization:ClearMap.Visualization.Plot.overlayPoints]{\emph{\code{overlayPoints()}}}}



\end{fulllineitems}

\index{plotOverlayLabel() (in module ClearMap.Visualization.Plot)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.Visualization:ClearMap.Visualization.Plot.plotOverlayLabel}\pysiglinewithargsret{\bfcode{plotOverlayLabel}}{\emph{dataSource}, \emph{labelSource}, \emph{alpha=False}, \emph{labelColorMap='jet'}, \emph{x=\textless{}built-in function all\textgreater{}}, \emph{y=\textless{}built-in function all\textgreater{}}, \emph{z=\textless{}built-in function all\textgreater{}}, \emph{tiling='automatic'}, \emph{maxtiles=20}}{}
Plot gray scale image overlayed with labeled image
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{dataSouce} (\emph{str or array}) --
volumetric image data

\item {} 
\textbf{labelSource} (\emph{str or array}) --
labeled image to be overlayed on the image data

\item {} 
\textbf{alpha} (\emph{float or False}) --
transparency

\item {} 
\textbf{labelColorMap} (\emph{str or object}) --
color map for the labels

\item {} 
\textbf{x, y, z} (\emph{all or tuple}) --
sub-range specification

\item {} 
\textbf{tiling} (\emph{str or tuple}) --
tiling specification

\item {} 
\textbf{maxtiles} --
maximalnumber of tiles

\end{itemize}

\item[{Returns}] \leavevmode
\emph{(object)} --
figure handle

\end{description}\end{quote}


\strong{See also:}


{\hyperref[api/ClearMap.Visualization:ClearMap.Visualization.Plot.overlayLabel]{\emph{\code{overlayLabel()}}}}



\end{fulllineitems}

\index{overlayPoints() (in module ClearMap.Visualization.Plot)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.Visualization:ClearMap.Visualization.Plot.overlayPoints}\pysiglinewithargsret{\bfcode{overlayPoints}}{\emph{dataSource, pointSource, sink=None, pointColor={[}1, 0, 0{]}, x=\textless{}built-in function all\textgreater{}, y=\textless{}built-in function all\textgreater{}, z=\textless{}built-in function all\textgreater{}}}{}
Overlay points on 3D data and return as color image
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{dataSouce} (\emph{str or array}) --
volumetric image data

\item {} 
\textbf{pointSource} (\emph{str or array}) --
point data to be overlayed on the image data

\item {} 
\textbf{pointColor} (\emph{array}) --
RGB color for the overlayed points

\item {} 
\textbf{x, y, z} (\emph{all or tuple}) --
sub-range specification

\end{itemize}

\item[{Returns}] \leavevmode
\emph{(str or array)} --
image overlayed with points

\end{description}\end{quote}


\strong{See also:}


{\hyperref[api/ClearMap.Visualization:ClearMap.Visualization.Plot.overlayLabel]{\emph{\code{overlayLabel()}}}}



\end{fulllineitems}

\index{plotOverlayPoints() (in module ClearMap.Visualization.Plot)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.Visualization:ClearMap.Visualization.Plot.plotOverlayPoints}\pysiglinewithargsret{\bfcode{plotOverlayPoints}}{\emph{dataSource, pointSource, pointColor={[}1, 0, 0{]}, x=\textless{}built-in function all\textgreater{}, y=\textless{}built-in function all\textgreater{}, z=\textless{}built-in function all\textgreater{}}}{}
Plot points overlayed on gray scale 3d image as tiles.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{dataSouce} (\emph{str or array}) --
volumetric image data

\item {} 
\textbf{pointSource} (\emph{str or array}) --
point data to be overlayed on the image data

\item {} 
\textbf{pointColor} (\emph{array}) --
RGB color for the overlayed points

\item {} 
\textbf{x, y, z} (\emph{all or tuple}) --
sub-range specification

\end{itemize}

\item[{Returns}] \leavevmode
\emph{(object)} --
figure handle

\end{description}\end{quote}


\strong{See also:}


{\hyperref[api/ClearMap.Visualization:ClearMap.Visualization.Plot.plotTiling]{\emph{\code{plotTiling()}}}}



\end{fulllineitems}

\index{test() (in module ClearMap.Visualization.Plot)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.Visualization:ClearMap.Visualization.Plot.test}\pysiglinewithargsret{\bfcode{test}}{}{}
Test Plot module

\end{fulllineitems}



\subsubsection{ClearMap.Parameter module}
\label{api/ClearMap.Parameter:module-ClearMap.Parameter}\label{api/ClearMap.Parameter:clearmap-parameter-module}\label{api/ClearMap.Parameter::doc}\index{ClearMap.Parameter (module)}
ClearMap default parameter module.

This module defines default parameter used by various sub-packages.


\strong{See also:}


{\hyperref[api/ClearMap.Settings:module-ClearMap.Settings]{\emph{\code{Settings}}}}


\index{detectCellParameter (in module ClearMap.Parameter)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.Parameter:ClearMap.Parameter.detectCellParameter}\pysigline{\bfcode{detectCellParameter}\strong{ = \{`findExtendedMaximaParameter': \{`threshold': 0, `save': None, `verbose': False, `hMax': 20, `size': 5\}, `correctIlluminationParameter': \{`scaling': `Mean', `flatfield': True, `save': None, `verbose': False, `background': None\}, `removeBackgroundParameter': \{`save': None, `verbose': False, `size': (15, 15)\}, `filterDoGParameter': \{`save': None, `sigma2': None, `sigma': None, `verbose': False, `size': (7, 7, 11)\}, `detectCellShapeParameter': \{`threshold': 700, `save': None, `verbose': False\}, `findIntensityParameter': \{`method': `Max', `size': (3, 3, 3)\}\}}}
dict: Paramters for cell detection using the spot detection algorithm


\strong{See also:}


{\hyperref[api/ClearMap.Parameter:ClearMap.Parameter.IlastikParameter]{\emph{\code{IlastikParameter}}}}, \code{StackProcessingParameter}



\end{fulllineitems}

\index{IlastikParameter (in module ClearMap.Parameter)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.Parameter:ClearMap.Parameter.IlastikParameter}\pysigline{\bfcode{IlastikParameter}\strong{ = \{`rescale': None, `backgroundSize': (15, 15), `classifier': `/Test/Ilastik/classifier.h5'\}}}
dict: Paramters for cell detection using Ilastik classification
\begin{itemize}
\item {} 
``classifier'': ilastic classifier to use

\item {} 
``rescale'': rescale images before classification

\item {} 
``backgroundSize'': Background correctoin: None or (y,x) which is size of disk for gray scale opening

\end{itemize}


\strong{See also:}


\code{SpotDetectionParameter}, \code{StackProcessingParameter}



\end{fulllineitems}

\index{processStackParameter (in module ClearMap.Parameter)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.Parameter:ClearMap.Parameter.processStackParameter}\pysigline{\bfcode{processStackParameter}\strong{ = \{`chunkOptimizationSize': \textless{}built-in function all\textgreater{}, `processes': 2, `chunkSizeMin': 30, `chunkOptimization': True, `cChunkOverlap': 15, `chunkSizeMax': 100\}}}~\begin{description}
\item[{dict: Parameter for processing an image stack in parallel}] \leavevmode\begin{itemize}
\item {} 
``processes'': max number of parallel processes

\item {} 
``chunkSizeMax'' : maximal chunk size in z

\item {} 
``chunkSizeMin'' : minimal chunk size in z,

\item {} 
``chunkOverlap'' : overlap between two chunks,

\item {} 
``chunkOptimization'': optimize chunk size and number to number of processes

\item {} 
``chunkOptimizationSize'': increase chunk size for optimizaition (True, False or all = automatic)

\end{itemize}

\end{description}


\strong{See also:}


\code{SpotDetectionParameter}, {\hyperref[api/ClearMap.Parameter:ClearMap.Parameter.IlastikParameter]{\emph{\code{IlastikParameter}}}}



\end{fulllineitems}

\index{AlignmentParameter (in module ClearMap.Parameter)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.Parameter:ClearMap.Parameter.AlignmentParameter}\pysigline{\bfcode{AlignmentParameter}\strong{ = \{`fixedImageMask': None, `alignmentDirectory': None, `movingImage': `/Test/Data/Elastix/150524\_0\_8X-s3-20HFautofluor\_18-51-1-warpable.tif', `affineParameterFile': `/Test/Elastix/ElastixParameterAffine.txt', `bSplineParameterFile': `/Test/Elastix/ElastixParameterBSpline.txt', `fixedImage': `/Test/Data/Elastix/OstenRefARA\_v2\_lowerHalf.tif'\}}}
dict: Parameter for Elastix alignment
\begin{itemize}
\item {} 
``alignmentDirectory'' : directory to save the alignment result

\item {} 
``movingImage'': image to be aligned

\item {} 
``fixedImage'':  reference image

\item {} 
``affineParameterFile'': elastix parameter files for affine alignment

\item {} 
``bSplineParameterFile'' : elastix parameter files for non-linear alignment

\end{itemize}


\strong{See also:}


{\hyperref[api/ClearMap.Alignment:module-ClearMap.Alignment.Elastix]{\emph{\code{Elastix}}}}



\end{fulllineitems}

\index{ResamplingParameter (in module ClearMap.Parameter)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.Parameter:ClearMap.Parameter.ResamplingParameter}\pysigline{\bfcode{ResamplingParameter}\strong{ = \{`orientation': None, `source': None, `resolutionSink': (25, 25, 25), `sink': None, `resolutionSource': (4.0625, 4.0625, 3)\}}}
dict: Parameter for resampling data
\begin{quote}
\begin{itemize}
\item {} 
``source'' : data source file

\item {} 
``sink''   : data output file

\end{itemize}

``resolutionSource'': resolution of the raw data (in um / pixel) as (x,y,z)

``resolutionSink'' : resolution of the reference / atlas image (in um/ pixel) as (x,y,z)
\begin{description}
\item[{``orientation''}] \leavevmode{[}Orientation of the data set wrt reference as (x=1,y=2,z=3){]}
(-axis will invert the orientation, for other hemisphere use (-1, 2, 3), to exchnge x,y use (2,1,3) etc)

\end{description}
\end{quote}


\strong{See also:}


{\hyperref[api/ClearMap.Alignment:module-ClearMap.Alignment.Resampling]{\emph{\code{Resampling}}}}



\end{fulllineitems}

\index{VoxelizationParameter (in module ClearMap.Parameter)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.Parameter:ClearMap.Parameter.VoxelizationParameter}\pysigline{\bfcode{VoxelizationParameter}\strong{ = \{`method': `Spherical', `voxelizationSize': (1, 1, 1)\}}}
dict: Parameter to calculate density voxelization
\begin{itemize}
\item {} 
``method'': Method to voxelize: `Spherical','Rectangular, `Gaussian'

\item {} 
``voxelizationSize'': max size of the volume to be voxelized

\end{itemize}


\strong{See also:}


\code{voxelization}



\end{fulllineitems}



\subsubsection{ClearMap.Settings module}
\label{api/ClearMap.Settings:clearmap-settings-module}\label{api/ClearMap.Settings::doc}\label{api/ClearMap.Settings:module-ClearMap.Settings}\index{ClearMap.Settings (module)}
Module to set \emph{ClearMap's} internal parameter and paths to external programs.
\paragraph{Notes}

Edit the {\hyperref[api/ClearMap.Settings:ClearMap.Settings.setup]{\emph{\code{setup()}}}} routine to point to the ilastik and elastix paths
for specific hosts


\strong{See also:}

\begin{itemize}
\item {} 
{\hyperref[api/ClearMap.Settings:ClearMap.Settings.IlastikPath]{\emph{\code{IlastikPath}}}}

\item {} 
{\hyperref[api/ClearMap.Settings:ClearMap.Settings.ElastixPath]{\emph{\code{ElastixPath}}}}

\item {} 
{\hyperref[api/ClearMap.Parameter:module-ClearMap.Parameter]{\emph{\code{Parameter}}}}

\end{itemize}


\index{IlastikPath (in module ClearMap.Settings)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.Settings:ClearMap.Settings.IlastikPath}\pysigline{\bfcode{IlastikPath}\strong{ = `/home/ckirst/programs/ilastik-05/'}}
str: Absolute path to the Ilastik 0.5 installation
\paragraph{Notes}

\href{http://ilastik.org/}{Ilastik Webpage}

\href{http://old.ilastik.org/}{Ilastik 0.5 Download}

\end{fulllineitems}

\index{ElastixPath (in module ClearMap.Settings)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.Settings:ClearMap.Settings.ElastixPath}\pysigline{\bfcode{ElastixPath}\strong{ = `/home/ckirst/programs/elastix/'}}
str: Absolue path to the elastix installation
\paragraph{Notes}

\href{http://elastix.isi.uu.nl/}{Elastix Webpage}

\end{fulllineitems}

\index{setup() (in module ClearMap.Settings)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.Settings:ClearMap.Settings.setup}\pysiglinewithargsret{\bfcode{setup}}{}{}
Setup ClearMap for specific hosts
\paragraph{Notes}

Edit this routine to include special setttings for specific hosts


\strong{See also:}


{\hyperref[api/ClearMap.Settings:ClearMap.Settings.IlastikPath]{\emph{\code{IlastikPath}}}}, {\hyperref[api/ClearMap.Settings:ClearMap.Settings.ElastixPath]{\emph{\code{ElastixPath}}}}



\end{fulllineitems}

\index{clearMapPath() (in module ClearMap.Settings)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.Settings:ClearMap.Settings.clearMapPath}\pysiglinewithargsret{\bfcode{clearMapPath}}{}{}
Returns root path to the ClearMap software
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\emph{str} --
root path to ClearMap

\end{description}\end{quote}

\end{fulllineitems}

\index{ClearMapPath (in module ClearMap.Settings)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.Settings:ClearMap.Settings.ClearMapPath}\pysigline{\bfcode{ClearMapPath}\strong{ = `/home/ckirst/Science/Projects/BrainActivityMap/Analysis/ClearMap'}}
str: Absolute path to the ClearMap root folder

\end{fulllineitems}



\subsubsection{ClearMap.Utils package}
\label{api/ClearMap.Utils:module-ClearMap.Utils}\label{api/ClearMap.Utils::doc}\label{api/ClearMap.Utils:clearmap-utils-package}\index{ClearMap.Utils (module)}
This sub-package provides utility functions used throughout the package

Author
\begin{quote}

Christoph Kirst, The Rockefeller University, New York City, 2015
\end{quote}


\paragraph{ClearMap.Utils.ParameterTools module}
\label{api/ClearMap.Utils:module-ClearMap.Utils.ParameterTools}\label{api/ClearMap.Utils:clearmap-utils-parametertools-module}\index{ClearMap.Utils.ParameterTools (module)}
ParameterTools

Provides simple formatting tools to handle / print parameter dictionaries
organized as key:value pairs.

Author
\begin{quote}

Christoph Kirst, The Rockefeller University, New York City, 2015
\end{quote}
\index{getParameter() (in module ClearMap.Utils.ParameterTools)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.Utils:ClearMap.Utils.ParameterTools.getParameter}\pysiglinewithargsret{\bfcode{getParameter}}{\emph{parameter}, \emph{key}, \emph{default=None}}{}
Gets a parameter from a dict, returns default value if not defined
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{parameter} (\emph{dict}) --
parameter dictionary

\item {} 
\textbf{key} (\emph{object}) --
key

\item {} 
\textbf{default} (\emph{object}) --
deault return value if parameter not defined

\end{itemize}

\item[{Returns}] \leavevmode
\emph{object} --
parameter value for key

\end{description}\end{quote}

\end{fulllineitems}

\index{writeParameter() (in module ClearMap.Utils.ParameterTools)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.Utils:ClearMap.Utils.ParameterTools.writeParameter}\pysiglinewithargsret{\bfcode{writeParameter}}{\emph{head=None}, \emph{out=None}, \emph{**args}}{}
Writes parameter settings in a formatted way
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{head} (\emph{str or None}) --
prefix of each line

\item {} 
\textbf{out} (\emph{object or None}) --
write to a specific output, if None return string

\item {} 
\textbf{**args} --
the parameter values as key=value arguments

\end{itemize}

\item[{Returns}] \leavevmode
\emph{str or None} --
a formated string with parameter info

\end{description}\end{quote}

\end{fulllineitems}

\index{joinParameter() (in module ClearMap.Utils.ParameterTools)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.Utils:ClearMap.Utils.ParameterTools.joinParameter}\pysiglinewithargsret{\bfcode{joinParameter}}{\emph{*args}}{}
Joins dictionaries in a consitent way

For multiple occurences of a key the  value is defined by the first key : value pair.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{*args} --
list of parameter dictonaries

\item[{Returns}] \leavevmode
\emph{dict} --
the joined dictionary

\end{description}\end{quote}

\end{fulllineitems}



\paragraph{ClearMap.Utils.ProcessWriter module}
\label{api/ClearMap.Utils:module-ClearMap.Utils.ProcessWriter}\label{api/ClearMap.Utils:clearmap-utils-processwriter-module}\index{ClearMap.Utils.ProcessWriter (module)}
Provides simple formatting tools to print text with parallel process header

Author
\begin{quote}

Christoph Kirst, The Rockefeller University, New York City, 2015
\end{quote}
\index{ProcessWriter (class in ClearMap.Utils.ProcessWriter)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.Utils:ClearMap.Utils.ProcessWriter.ProcessWriter}\pysiglinewithargsret{\strong{class }\bfcode{ProcessWriter}}{\emph{process=0}}{}
Bases: \code{object}

Class to handle writing from parallel processes
\index{process (ProcessWriter attribute)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.Utils:ClearMap.Utils.ProcessWriter.ProcessWriter.process}\pysigline{\bfcode{process}}
\emph{int}

the process number

\end{fulllineitems}

\index{writeString() (ProcessWriter method)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.Utils:ClearMap.Utils.ProcessWriter.ProcessWriter.writeString}\pysiglinewithargsret{\bfcode{writeString}}{\emph{text}}{}
Generate string with process prefix
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{text} (\emph{str}) --
the text input

\item[{Returns}] \leavevmode
\emph{str} --
text with {[}process prefix

\end{description}\end{quote}

\end{fulllineitems}

\index{write() (ProcessWriter method)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.Utils:ClearMap.Utils.ProcessWriter.ProcessWriter.write}\pysiglinewithargsret{\bfcode{write}}{\emph{text}}{}
Write string with process prefix to sys.stdout
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{text} (\emph{str}) --
the text input

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\paragraph{ClearMap.Utils.Timer module}
\label{api/ClearMap.Utils:module-ClearMap.Utils.Timer}\label{api/ClearMap.Utils:clearmap-utils-timer-module}\index{ClearMap.Utils.Timer (module)}
Provides tools for timing

Author
\begin{quote}

Christoph Kirst, The Rockefeller University, New York City, 2015
\end{quote}
\index{Timer (class in ClearMap.Utils.Timer)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.Utils:ClearMap.Utils.Timer.Timer}\pysiglinewithargsret{\strong{class }\bfcode{Timer}}{\emph{verbose=False}}{}
Bases: \code{object}

Class to stop time and print results in formatted way
\index{time (Timer attribute)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.Utils:ClearMap.Utils.Timer.Timer.time}\pysigline{\bfcode{time}}
\emph{float}

the time since the timer was started

\end{fulllineitems}

\index{start() (Timer method)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.Utils:ClearMap.Utils.Timer.Timer.start}\pysiglinewithargsret{\bfcode{start}}{}{}
Start the timer

\end{fulllineitems}

\index{reset() (Timer method)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.Utils:ClearMap.Utils.Timer.Timer.reset}\pysiglinewithargsret{\bfcode{reset}}{}{}
Reset the timer

\end{fulllineitems}

\index{elapsedTime() (Timer method)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.Utils:ClearMap.Utils.Timer.Timer.elapsedTime}\pysiglinewithargsret{\bfcode{elapsedTime}}{\emph{head=None}, \emph{asstring=True}}{}
Calculate elapsed time and return as formated string
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{head} (\emph{str or None}) --
prefix to the string

\item {} 
\textbf{asstring} (\emph{bool}) --
return as string or float

\end{itemize}

\item[{Returns}] \leavevmode
\emph{str or float} --
elapsed time

\end{description}\end{quote}

\end{fulllineitems}

\index{printElapsedTime() (Timer method)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.Utils:ClearMap.Utils.Timer.Timer.printElapsedTime}\pysiglinewithargsret{\bfcode{printElapsedTime}}{\emph{head=None}}{}
Print elapsed time as formated string
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{head} (\emph{str or None}) --
prefix to the string

\end{description}\end{quote}

\end{fulllineitems}

\index{formatElapsedTime() (Timer method)}

\begin{fulllineitems}
\phantomsection\label{api/ClearMap.Utils:ClearMap.Utils.Timer.Timer.formatElapsedTime}\pysiglinewithargsret{\bfcode{formatElapsedTime}}{\emph{t}}{}
Format time to string
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{t} (\emph{float}) --
time in seconds prefix

\item[{Returns}] \leavevmode
\emph{str} --
time as hours:minutes:seconds

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\chapter{Indices}
\label{index:indices}\begin{itemize}
\item {} 
\DUspan{xref,std,std-ref}{genindex}

\item {} 
\DUspan{xref,std,std-ref}{modindex}

\item {} 
\DUspan{xref,std,std-ref}{search}

\end{itemize}


\chapter{Quickstart}
\label{index:quickstart}
Install ClearMap by downloading it form \href{http://www.github.com/}{github}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZdl{} git clone git@git.assembla.com:idisco.git
\end{Verbatim}

You can access documentation in the interpreter with Python's built-in help
function:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{ClearMap} \PYG{k+kn}{as} \PYG{n+nn}{cm}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{help}\PYG{p}{(}\PYG{n}{cm}\PYG{p}{)}
\end{Verbatim}

For more details see the {\hyperref[introduction::doc]{\emph{\emph{Introduction}}}}, the \code{examples} and the :doc:{\color{red}\bfseries{}{}`}api/ClearMap {}` section.


\chapter{Author}
\label{index:author}
Christoph Kirst,
The Rockefeller University, New York Ciy, 2015


\chapter{License}
\label{index:license}
GNU GENERAL PUBLIC LICENSE Version 3

See \code{LICENSE} or \href{http://www.gnu.org/licenses/gpl-3.0.en.html}{gnu.org} for details.

\begin{thebibliography}{Renier2014}
\bibitem[Renier2014]{Renier2014}{\phantomsection\label{introduction:renier2014} 
\href{http://dx.doi.org/10.1016/j.cell.2014.10.010}{iDISCO: A Simple, Rapid Method to Immunolabel Large Tissue Samples
for Volume Imaging, N. Renier, et al. 2014}
}
\bibitem[Renier2015]{Renier2015}{\phantomsection\label{introduction:renier2015} 
`Mapping brain activity in the mouse at cellular resolution
with volume imaging using immediate early genes, N. Renier, et al. in prep.
}
\bibitem[iDISCO]{iDISCO}{\phantomsection\label{introduction:idisco} 
{\color{red}\bfseries{}{}`iDISCO webpage, http://idisco.info/ \textless{} http://idisco.info/\textgreater{}{}`\_}
}
\bibitem[ABA]{ABA}{\phantomsection\label{introduction:aba} 
\href{http://www.brain-map.org/}{Allan Brain Atlas, http://www.brain-map.org/.}
}
\bibitem[Elastix]{Elastix}{\phantomsection\label{introduction:elastix} 
\href{http://elastix.isi.uu.nl}{Elastix toolbox for rigid and nonrigid registration of
images, http://elastix.isi.uu.nl}
}
\bibitem[Ilastik]{Ilastik}{\phantomsection\label{introduction:ilastik} 
\href{http://ilastik.org/}{Ilastik the interactive learning and segmentation toolkit,
http://ilastik.org/}
}
\bibitem[ImageJ]{ImageJ}{\phantomsection\label{introduction:imagej} 
\href{http://imagej.net/Welcome}{ImageJ}
}
\end{thebibliography}


\renewcommand{\indexname}{Python Module Index}
\begin{theindex}
\def\bigletter#1{{\Large\sffamily#1}\nopagebreak\vspace{1mm}}
\bigletter{c}
\item {\texttt{ClearMap}}, \pageref{api/ClearMap:module-ClearMap}
\item {\texttt{ClearMap.Alignment}}, \pageref{api/ClearMap.Alignment:module-ClearMap.Alignment}
\item {\texttt{ClearMap.Alignment.Elastix}}, \pageref{api/ClearMap.Alignment:module-ClearMap.Alignment.Elastix}
\item {\texttt{ClearMap.Alignment.Resampling}}, \pageref{api/ClearMap.Alignment:module-ClearMap.Alignment.Resampling}
\item {\texttt{ClearMap.Analysis}}, \pageref{api/ClearMap.Analysis:module-ClearMap.Analysis}
\item {\texttt{ClearMap.Analysis.Label}}, \pageref{api/ClearMap.Analysis:module-ClearMap.Analysis.Label}
\item {\texttt{ClearMap.Analysis.Statistics}}, \pageref{api/ClearMap.Analysis:module-ClearMap.Analysis.Statistics}
\item {\texttt{ClearMap.Analysis.Tools}}, \pageref{api/ClearMap.Analysis.Tools:module-ClearMap.Analysis.Tools}
\item {\texttt{ClearMap.Analysis.Tools.Extrapolate}}, \pageref{api/ClearMap.Analysis.Tools:module-ClearMap.Analysis.Tools.Extrapolate}
\item {\texttt{ClearMap.Analysis.Tools.MultipleComparisonCorrection}}, \pageref{api/ClearMap.Analysis.Tools:module-ClearMap.Analysis.Tools.MultipleComparisonCorrection}
\item {\texttt{ClearMap.Analysis.Tools.StatisticalTests}}, \pageref{api/ClearMap.Analysis.Tools:module-ClearMap.Analysis.Tools.StatisticalTests}
\item {\texttt{ClearMap.Analysis.Voxelization}}, \pageref{api/ClearMap.Analysis:module-ClearMap.Analysis.Voxelization}
\item {\texttt{ClearMap.ImageProcessing}}, \pageref{api/ClearMap.ImageProcessing:module-ClearMap.ImageProcessing}
\item {\texttt{ClearMap.ImageProcessing.BackgroundRemoval}}, \pageref{api/ClearMap.ImageProcessing:module-ClearMap.ImageProcessing.BackgroundRemoval}
\item {\texttt{ClearMap.ImageProcessing.CellDetection}}, \pageref{api/ClearMap.ImageProcessing:module-ClearMap.ImageProcessing.CellDetection}
\item {\texttt{ClearMap.ImageProcessing.CellSizeDetection}}, \pageref{api/ClearMap.ImageProcessing:module-ClearMap.ImageProcessing.CellSizeDetection}
\item {\texttt{ClearMap.ImageProcessing.Filter}}, \pageref{api/ClearMap.ImageProcessing.Filter:module-ClearMap.ImageProcessing.Filter}
\item {\texttt{ClearMap.ImageProcessing.Filter.Convolution}}, \pageref{api/ClearMap.ImageProcessing.Filter:module-ClearMap.ImageProcessing.Filter.Convolution}
\item {\texttt{ClearMap.ImageProcessing.Filter.DoGFilter}}, \pageref{api/ClearMap.ImageProcessing.Filter:module-ClearMap.ImageProcessing.Filter.DoGFilter}
\item {\texttt{ClearMap.ImageProcessing.Filter.FilterKernel}}, \pageref{api/ClearMap.ImageProcessing.Filter:module-ClearMap.ImageProcessing.Filter.FilterKernel}
\item {\texttt{ClearMap.ImageProcessing.Filter.LinearFilter}}, \pageref{api/ClearMap.ImageProcessing.Filter:module-ClearMap.ImageProcessing.Filter.LinearFilter}
\item {\texttt{ClearMap.ImageProcessing.Filter.StructureElement}}, \pageref{api/ClearMap.ImageProcessing.Filter:module-ClearMap.ImageProcessing.Filter.StructureElement}
\item {\texttt{ClearMap.ImageProcessing.GreyReconstruction}}, \pageref{api/ClearMap.ImageProcessing:module-ClearMap.ImageProcessing.GreyReconstruction}
\item {\texttt{ClearMap.ImageProcessing.IlastikClassification}}, \pageref{api/ClearMap.ImageProcessing:module-ClearMap.ImageProcessing.IlastikClassification}
\item {\texttt{ClearMap.ImageProcessing.IlluminationCorrection}}, \pageref{api/ClearMap.ImageProcessing:module-ClearMap.ImageProcessing.IlluminationCorrection}
\item {\texttt{ClearMap.ImageProcessing.MaximaDetection}}, \pageref{api/ClearMap.ImageProcessing:module-ClearMap.ImageProcessing.MaximaDetection}
\item {\texttt{ClearMap.ImageProcessing.SpotDetection}}, \pageref{api/ClearMap.ImageProcessing:module-ClearMap.ImageProcessing.SpotDetection}
\item {\texttt{ClearMap.ImageProcessing.StackProcessing}}, \pageref{api/ClearMap.ImageProcessing:module-ClearMap.ImageProcessing.StackProcessing}
\item {\texttt{ClearMap.IO}}, \pageref{api/ClearMap.IO:module-ClearMap.IO}
\item {\texttt{ClearMap.IO.CSV}}, \pageref{api/ClearMap.IO:module-ClearMap.IO.CSV}
\item {\texttt{ClearMap.IO.FileList}}, \pageref{api/ClearMap.IO:module-ClearMap.IO.FileList}
\item {\texttt{ClearMap.IO.Imaris}}, \pageref{api/ClearMap.IO:module-ClearMap.IO.Imaris}
\item {\texttt{ClearMap.IO.IO}}, \pageref{api/ClearMap.IO:module-ClearMap.IO.IO}
\item {\texttt{ClearMap.IO.NPY}}, \pageref{api/ClearMap.IO:module-ClearMap.IO.NPY}
\item {\texttt{ClearMap.IO.NRRD}}, \pageref{api/ClearMap.IO:module-ClearMap.IO.NRRD}
\item {\texttt{ClearMap.IO.RAW}}, \pageref{api/ClearMap.IO:module-ClearMap.IO.RAW}
\item {\texttt{ClearMap.IO.TIF}}, \pageref{api/ClearMap.IO:module-ClearMap.IO.TIF}
\item {\texttt{ClearMap.IO.VTK}}, \pageref{api/ClearMap.IO:module-ClearMap.IO.VTK}
\item {\texttt{ClearMap.Parameter}}, \pageref{api/ClearMap.Parameter:module-ClearMap.Parameter}
\item {\texttt{ClearMap.Settings}}, \pageref{api/ClearMap.Settings:module-ClearMap.Settings}
\item {\texttt{ClearMap.Utils}}, \pageref{api/ClearMap.Utils:module-ClearMap.Utils}
\item {\texttt{ClearMap.Utils.ParameterTools}}, \pageref{api/ClearMap.Utils:module-ClearMap.Utils.ParameterTools}
\item {\texttt{ClearMap.Utils.ProcessWriter}}, \pageref{api/ClearMap.Utils:module-ClearMap.Utils.ProcessWriter}
\item {\texttt{ClearMap.Utils.Timer}}, \pageref{api/ClearMap.Utils:module-ClearMap.Utils.Timer}
\item {\texttt{ClearMap.Visualization}}, \pageref{api/ClearMap.Visualization:module-ClearMap.Visualization}
\item {\texttt{ClearMap.Visualization.Plot}}, \pageref{api/ClearMap.Visualization:module-ClearMap.Visualization.Plot}
\end{theindex}

\renewcommand{\indexname}{Index}
\printindex
\end{document}
